<!DOCTYPE HTML>
<html lang="ga" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ag Obair Le hAon Líon Todhchaíochtaí - An Teanga Ríomhchláraithe Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/css/ferris.css">
        <link rel="stylesheet" href="src/css/2018-edition.css">
        <link rel="stylesheet" href="src/css/semantic-notes.css">
        <link rel="stylesheet" href="src/css/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">An Teanga Ríomhchláraithe Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/aindriu80/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="ag-obair-le-líon-ar-bith-de-thodhchaí"><a class="header" href="#ag-obair-le-líon-ar-bith-de-thodhchaí">Ag Obair le Líon ar bith de Thodhchaí</a></h2>
<p>Nuair a d'athraíomar ó dhá thodhchaí a úsáid go trí cinn sa chuid roimhe seo, b'éigean dúinn
freisin aistriú ó <code>join</code> a úsáid go <code>join3</code>. Bheadh ​​sé cráite
feidhm dhifriúil a ghlaoch gach uair a d'athraíomar líon na dtodhchaí a theastaigh uainn a bheith páirteach. Ar ámharaí an tsaoil, tá foirm macra de <code>join</code> againn ar féidir linn líon treallach argóintí a chur chuici. Láimhseálann sé fanacht leis na todhchaí féin freisin.
Dá bhrí sin, d'fhéadfaimis an cód ó Liostáil 17-13 a athscríobh chun <code>join!</code> a úsáid in ionad <code>join3</code>, mar atá i Liostáil 17-14.</p>
<Listing number="17-14" caption="Using `join!` to wait for multiple futures" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Is cinnte gur feabhas é seo ar an malartú idir <code>join</code> agus
<code>join3</code> agus <code>join4</code> agus mar sin de! Mar sin féin, ní oibríonn an fhoirm macra seo ach amháin
nuair a bhíonn a fhios againn cé mhéad todhchaí atá ann roimh ré. I Rust sa saol réadúil,
áfach, is patrún coitianta é todhchaí a bhrú isteach i mbailiúchán agus ansin fanacht ar chuid nó ar
gach todhchaí díobh a bheith críochnaithe.</p>
<p>Chun na todhchaí go léir i mbailiúchán éigin a sheiceáil, beidh orainn athrá a dhéanamh orthu agus
join a dhéanamh orthu <em>uile</em> acu. Glacann an fheidhm <code>trpl::join_all</code> le haon chineál a
chuireann an tréith <code>Iterator</code> i bhfeidhm, a d'fhoghlaim tú faoi i <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">An Tréith Iterator agus an Modh <code>next</code></a><!-- ignore --> Caibidil 13, mar sin
is cosúil gurb é an ticéad ceart é. Déanaimis iarracht ár dtodhchaí a chur i veicteoir agus
<code>join!</code> a athsholáthar le <code>join_all</code> mar a thaispeántar i Liostáil 17-15.</p>
<Listing  number="17-15" caption="Storing anonymous futures in a vector and calling `join_all`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Ar an drochuair, ní thiomsaíonn an cód seo. Ina áit sin, faighimid an earráid seo:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a 
different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
</code></pre>
<p>D’fhéadfadh sé seo a bheith ionadh. Tar éis an tsaoil, ní thugann aon cheann de na bloic asyncrónacha aon rud ar ais,
mar sin táirgeann gach ceann acu <code>Future&lt;Output = ()&gt;</code>. Cuimhnigh gur tréith í <code>Future</code>,
ach, agus go gcruthaíonn an tiomsaitheoir enum uathúil do gach bloc asyncrónach. Ní féidir leat dhá struchtúr lámhscríofa éagsúla a chur i <code>Vec</code>, agus baineann an riail chéanna
leis na enums éagsúla a ghineann an tiomsaitheoir.</p>
<p>Chun seo a chur ag obair, ní mór dúinn <em>trait objects</em> a úsáid, díreach mar a rinneamar i <a href="ch12-03-improving-error-handling-and-modularity.html">“Returning
Errors from the run function”</a><!-- ignore --> i gCaibidil 12. (Clúdóimid
trait objects go mion i gCaibidil 18.) Trí úsáid a bhaint as réada tréithe, is féidir linn gach
ceann de na todhchaí gan ainm a tháirgeann na cineálacha seo a chóireáil mar an gcineál céanna, toisc go gcuireann siad uile an tréith <code>Future</code> i bhfeidhm.</p>
<blockquote>
<p>Nóta: I rannóg Chaibidil 8 <a href="ch12-03-improving-error-handling-and-modularity.html#returning-errors-from-the-run-function">Úsáid Enum chun Illuachanna a Stóráil</a><!-- ignore -->, phléamar bealach eile chun ilchineálacha a áireamh i <code>Vec</code>: enum a úsáid chun gach cineál a fhéadfaidh a bheith le feiceáil sa
veicteoir a léiriú. Ní féidir linn é sin a dhéanamh anseo, áfach. Ar an gcéad dul síos, níl aon bhealach againn na cineálacha éagsúla a ainmniú, mar go bhfuil siad gan ainm. Ar an gcéad dul síos, ba é an chúis
ar shroicheamar veicteoir agus <code>join_all</code> ar an gcéad dul síos ná go mbeimid in ann oibriú
le bailiúchán dinimiciúil todhchaíochtaí nuair nach bhfuil cúram orainn ach go bhfuil an cineál
aschuir chéanna acu.</p>
</blockquote>
<p>Tosaímid trí gach todhchaí sa <code>vec!</code> a fhilleadh i <code>Box::new</code>, mar a thaispeántar i
Liostáil 17-16.</p>
<Listing number="17-16" caption="Using `Box::new` to align the types of the futures in a `Vec`" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Ar an drochuair, ní thiomsaíonn an cód seo fós. Déanta na fírinne, faighimid an earráid bhunúsach chéanna a fuair muid roimhe seo don dara agus don tríú glao <code>Box::new</code> araon, chomh maith le
earráidí nua a thagraíonn don tréith <code>Unpin</code>. Fillfimid ar na hearráidí <code>Unpin</code> i gceann tamaill. Ar dtús, déanaimis na hearráidí cineáil ar na glaonna <code>Box::new</code> a shocrú trí
chineál an athróg <code>futures</code> a anótáil go sainráite (féach Liostáil 17-17).</p>
<Listing number="17-17" caption="Fixing the rest of the type mismatch errors by using an explicit type declaration" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Tá an dearbhú cineáil seo beagáinín casta, mar sin déanaimis scrúdú air:</p>
<ol>
<li>
<p>Is é an todhchaí féin an cineál is istigh. Tugaimid faoi deara go soiléir gurb é aschur an todhchaí an cineál aonaid <code>()</code> trí <code>Future&lt;Output = ()&gt;</code> a scríobh.</p>
</li>
<li>
<p>Ansin, cuirimid <code>dyn</code> leis an tréith chun é a mharcáil mar dhinimiciúil.</p>
</li>
<li>
<p>Tá an tagairt tréithe iomlán fillte i <code>Box</code>.</p>
</li>
<li>
<p>Ar deireadh, luaimid go soiléir gur <code>Vec</code> é <code>futures</code> ina bhfuil na míreanna seo.</p>
</li>
</ol>
<p>Rinne sin difríocht mhór cheana féin. Anois nuair a ritheann muid an tiomsaitheoir, ní bhfaighimid ach
na hearráidí ina luaitear <code>Unpin</code>. Cé go bhfuil trí cinn acu ann, tá a n-ábhar
an-chosúil.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
# copy *only* the errors
# fix the paths
-->
<pre><code class="language-text">error[E0308]: mismatched types
   --&gt; src/main.rs:46:46
    |
10  |         let tx1_fut = async move {
    |                       ---------- the expected `async` block
...
24  |         let rx_fut = async {
    |                      ----- the found `async` block
...
46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
    |                                     -------- ^^^^^^ expected `async` block, found a different `async` block
    |                                     |
    |                                     arguments to this function are incorrect
    |
    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
               found `async` block `{async block@src/main.rs:24:22: 24:27}`
    = note: no two async blocks, even if identical, have the same type
    = help: consider pinning your async block and casting it to a trait object
note: associated function defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/alloc/src/boxed.rs:255:12
    |
255 |     pub fn new(x: T) -&gt; Self {
    |            ^^^

error[E0308]: mismatched types
   --&gt; src/main.rs:46:64
    |
10  |         let tx1_fut = async move {
    |                       ---------- the expected `async` block
...
30  |         let tx_fut = async move {
    |                      ---------- the found `async` block
...
46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
    |                                                       -------- ^^^^^^ expected `async` block, found a different `async` block
    |                                                       |
    |                                                       arguments to this function are incorrect
    |
    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
               found `async` block `{async block@src/main.rs:30:22: 30:32}`
    = note: no two async blocks, even if identical, have the same type
    = help: consider pinning your async block and casting it to a trait object
note: associated function defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/alloc/src/boxed.rs:255:12
    |
255 |     pub fn new(x: T) -&gt; Self {
    |            ^^^

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
   --&gt; src/main.rs:48:24
    |
48  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `join_all`
   --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all&lt;I&gt;(iter: I) -&gt; JoinAll&lt;I::Item&gt;
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:9
   |
48 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p>Is <em>a lán</em> é sin le díleá, mar sin déanaimis é a scaradh óna chéile. Insíonn an chéad chuid den teachtaireacht dúinn nach gcuireann an chéad bhloc asyncrónach (<code>src/main.rs:8:23: 20:10</code>)
an tréith <code>Unpin</code> i bhfeidhm agus molann sé <code>pin!</code> nó <code>Box::pin</code> a úsáid chun
é a réiteach. Níos déanaí sa chaibidil, déanfaimid tochailt isteach i roinnt sonraí eile faoi <code>Pin</code> agus
<code>Unpin</code>. I láthair na huaire, áfach, is féidir linn comhairle an tiomsaitheora a leanúint chun
dícheangal. I Liostáil 17-18, tosaímid tríd an nóta cineáil do
<code>futures</code> a nuashonrú, le <code>Pin</code> ag timfhilleadh gach <code>Box</code>. Ar an dara dul síos, úsáidimid <code>Box::pin</code> chun
na todhchaí féin a phionáil.</p>
<Listing number="17-18" caption="Using `Pin` and `Box::pin` to make the `Vec` type check" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let rx_fut = pin!(async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let tx_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span>        let futures: Vec&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt; =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Má dhéanaimid é seo a thiomsú agus a rith, gheobhaimid an t-aschur a raibh súil againn leis sa deireadh:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'messages'
received 'the'
received 'for'
received 'future'
received 'you'
</code></pre>
<p>Ó, a Dhia!</p>
<p>Tá beagán eile le fiosrú anseo. Ar an gcéad dul síos, cuireann úsáid a bhaint as <code>Pin&lt;Box&lt;T&gt;&gt;</code> beagán forchostais leis ó na todhchaí seo a chur ar an gcarn le <code>Box</code>—agus
nílimid ag déanamh sin ach chun na cineálacha a ailíniú. Ní <em>gá</em> linn i ndáiríre an
leithdháileadh carn, tar éis an tsaoil: tá na todhchaí seo áitiúil don fheidhm seo.
Mar a luadh cheana, is cineál fillteáin é <code>Pin</code> féin, mar sin is féidir linn leas a bhaint as
cineál amháin a bheith againn sa <code>Vec</code>—an chúis bhunaidh ar shroicheamar <code>Box</code>—gan leithdháileadh carn a dhéanamh. Is féidir linn <code>Pin</code> a úsáid go díreach le gach
todhchaí, ag baint úsáide as an macra <code>std::pin::pin</code>.</p>
<p>Mar sin féin, ní mór dúinn a bheith soiléir fós faoin gcineál tagartha bioráilte;
seach sin, ní bheidh a fhios ag Rust fós conas iad seo a léirmhíniú mar réada tréithe dinimiciúla,
agus sin an rud a theastaíonn uainn uathu a bheith sa <code>Vec</code>. Dá bhrí sin, déanaimid gach todhchaí a phionáil nuair a shainmhínímid í, agus sainmhínímid <code>futures</code> mar <code>Vec</code> ina bhfuil tagairtí inathraithe bioráilte don chineál todhchaí dinimiciúil, mar atá i Liostáil 17-19.</p>
<Listing number="17-19" caption="Using `Pin` directly with the `pin!` macro to avoid unnecessary heap allocations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let rx_fut = pin!(async {
            // --snip--
<span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span>        });

        let tx_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Shroicheamar an méid seo trí neamhaird a dhéanamh den fhíric go bhféadfadh cineálacha éagsúla <code>Output</code> a bheith againn. Mar shampla, i Liosta 17-20, cuireann an todhchaí gan ainm le haghaidh <code>a</code> <code>Future&lt;Output = u32&gt;</code> i bhfeidhm, cuireann an todhchaí gan ainm le haghaidh <code>b</code> <code>Future&lt;Output = &amp;str&gt;</code> i bhfeidhm, agus cuireann an todhchaí gan ainm le haghaidh <code>c</code> <code>Future&lt;Output = bool&gt;</code> i bhfeidhm.</p>
<Listing number="17-20" caption="Three futures with distinct types" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async { 1u32 };
        let b = async { "Hello!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Is féidir linn <code>trpl::join!</code> a úsáid chun fanacht leo, mar go gceadaíonn sé dúinn cineálacha éagsúla todhchaí a chur isteach agus táirgeann sé tuple de na cineálacha sin. Ní féidir linn <code>trpl::join_all</code> a úsáid, mar éilíonn sé go mbeidh an cineál céanna ag na todhchaí go léir a chuirtear isteach. Cuimhnigh, is é an earráid sin a chuir tús linn ar an eachtra seo le
<code>Pin</code>!</p>
<p>Is comhbhabhtáil bhunúsach í seo: is féidir linn déileáil le líon dinimiciúil
todhchaí le <code>join_all</code>, fad is atá an cineál céanna acu go léir, nó is féidir linn déileáil
le líon socraithe todhchaí leis na feidhmeanna <code>join</code> nó leis an macra <code>join!</code>,
fiú má tá cineálacha difriúla acu. Is é seo an cás céanna a mbeadh orainn aghaidh a thabhairt air agus muid
ag obair le haon chineálacha eile i Rust. Níl todhchaí speisialta, cé go bhfuil
roinnt comhréir deas againn chun oibriú leo, agus is rud maith é sin.</p>
<h3 id="todhchaí-rásaíochta"><a class="header" href="#todhchaí-rásaíochta">Todhchaí Rásaíochta</a></h3>
<p>Nuair a "cheanglaímid" todhchaí leis an teaghlach feidhmeanna agus macraí <code>join</code>,
ní mór dúinn <em>gach</em> ceann acu a chríochnú sula mbogann muid ar aghaidh. Uaireanta, áfach, ní gá ach <em>roinnt</em> todhchaí ó shraith a chríochnú sula mbogann muid ar aghaidh—rud beag cosúil le
rásaíocht a dhéanamh idir todhchaí amháin agus todhchaí eile.</p>
<p>I Liostáil 17-21, úsáidimid <code>trpl::race</code> arís chun dhá thodhchaí, <code>slow</code> agus
<code>fast</code>, a rith i gcoinne a chéile.</p>
<Listing number="17-21" caption="Using `race` to get the result of whichever future finishes first" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            println!("'slow' started.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' finished.");
        };

        let fast = async {
            println!("'fast' started.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' finished.");
        };

        trpl::race(slow, fast).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Priontálann gach todhchaí teachtaireacht nuair a thosaíonn sé ag rith, sosann sé ar feadh tamaill
trí ghlaoch agus fanacht le <code>sleep</code>, agus ansin priontálann sé teachtaireacht eile nuair a
chríochnaíonn sé. Ansin, cuirimid <code>slow</code> agus <code>fast</code> araon chuig <code>trpl::race</code> agus fanfaimid go gcríochnóidh ceann
dóibh. (Níl an toradh anseo ró-iontach: buaileann <code>fast</code>.) Murab ionann agus
nuair a d'úsáideamar <code>race</code> ar ais in <a href="ch17-01-futures-and-syntax.html#our-first-async-program">“Ár gCéad Chlár Asyncrónach”</a><!--
ignore -->, ní dhéanaimid ach neamhaird den chás <code>Either</code> a thugann sé ar ais anseo, toisc go dtarlaíonn an t-iompar suimiúil go léir i gcorp na mbloc asyncrónach.</p>
<p>Tabhair faoi deara má athraíonn tú ord na n-argóintí go <code>race</code>, athraíonn ord na
dteachtaireachtaí “tosaithe”, cé go gcríochnaíonn an todhchaí <code>fast</code> i gcónaí
ar dtús. Sin toisc nach bhfuil cur i bhfeidhm na feidhme <code>race</code> seo cothrom. Ritheann sé na todhchaí a chuirtear isteach mar argóintí i gcónaí san ord ina
ritheann siad. Tá cur i bhfeidhm eile <em>cóir</em> agus roghnóidh siad go randamach
cé acu todhchaí le vótaíocht ar dtús. Beag beann ar cibé an bhfuil cur i bhfeidhm an chine
atá á úsáid againn cothrom, áfach, rithfidh <em>ceann</em> de na todhchaí suas go dtí an chéad
<code>await</code> ina chorp sula bhféadfar tasc eile a thosú.</p>
<p>Meabhraigh ó <a href="ch17-01-futures-and-syntax.html#our-first-async-program">Ár gCéad Chlár Asyncrónach</a><!-- ignore --> go dtugann Rust deis d'am rith an tasc a chur ar sos agus aistriú go
ceann eile mura bhfuil an todhchaí atá á fanacht réidh. Tá an rud eile fíor freisin:
Cuireann Rust <em>only</em> sos ar bhloic asyncrónacha agus tugann sé an rialú ar ais go ham rith ag pointe feithimh.
Tá gach rud idir pointí feithimh sioncrónach.</p>
<p>Ciallaíonn sé sin má dhéanann tú go leor oibre i mbloc asyncrónach gan pointe feithimh,
go gcuirfidh an todhchaí sin bac ar aon todhchaí eile ó dhul chun cinn a dhéanamh. Uaireanta, d'fhéadfá
é seo a chloisteáil mar thodhchaí amháin ag <em>ocras</em> todhchaí eile. I gcásanna áirithe,
b'fhéidir nach mbeadh sé sin ina mhórcheist. Mar sin féin, má tá tú ag déanamh cineál éigin oibre costasaí
suite nó oibre fadtréimhseach, nó má tá todhchaí agat a leanfaidh ort ag déanamh tasc áirithe
go deo, beidh ort smaoineamh ar cathain agus cá háit le rialú a thabhairt ar ais don am rith.</p>
<p>Ar an gcaoi chéanna, má tá oibríochtaí blocála fadtréimhseacha agat, is féidir le haisioncrónach a bheith ina
uirlis úsáideach chun bealaí a sholáthar do chodanna éagsúla den chlár baint a bheith acu
le chéile.</p>
<p>Ach <em>conas</em> a thabharfá rialú ar ais don am rith sna cásanna sin?</p>
<!-- Seancheannteidil. Ná bain iad nó d'fhéadfadh naisc briseadh. -->
<p><a id="yielding"></a></p>
<h3 id="rialú-a-thabhairt-don-am-rith"><a class="header" href="#rialú-a-thabhairt-don-am-rith">Rialú a Thabhairt don Am Rith</a></h3>
<p>Déanaimis oibríocht fhada a insamhladh. Tugann liostú 17-22 feidhm <code>slow</code> isteach.</p>
<Listing number="17-22" caption="Using `thread::sleep` to simulate slow operations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // We will call `slow` here later
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}</code></pre></pre>
</Listing>
<p>Úsáideann an cód seo <code>std::thread::sleep</code> in ionad <code>trpl::sleep</code> ionas go gcuirfidh glaoch ar <code>slow</code> bac ar an snáithe reatha ar feadh roinnt milleasoicindí. Is féidir linn <code>slow</code> a úsáid chun seasamh in ionad oibríochtaí fíorshaoil ​​atá ag rith ar feadh i bhfad agus
ag blocáil.</p>
<p>I Liosta 17-23, úsáidimid <code>slow</code> chun aithris a dhéanamh ar an gcineál seo oibre atá ceangailte le LAP i
béire todhchaí.</p>
<Listing number="17-23" caption="Using `thread::sleep` to simulate slow operations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finished.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Ar dtús, ní thugann gach todhchaí ach an rialú ar ais chuig an am rite <em>tar éis</em> roinnt oibríochtaí mall a dhéanamh. Má ritheann tú an cód seo, feicfidh tú an t-aschur seo:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23/
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>Mar atá lenár sampla níos luaithe, críochnaíonn <code>race</code> a luaithe is a bhíonn <code>a</code> críochnaithe.
Níl aon idirnascadh idir an dá thodhchaí, áfach. Déanann an todhchaí <code>a</code> a chuid oibre go léir go dtí go bhfanann an glao <code>trpl::sleep</code>, ansin déanann an todhchaí <code>b</code> a chuid oibre go léir go dtí go bhfanann a glao <code>trpl::sleep</code> féin, agus ar deireadh críochnaíonn an todhchaí <code>a</code>. Chun ligean don dá thodhchaí dul chun cinn a dhéanamh idir a gcuid tascanna mall, teastaíonn pointí feithimh uainn ionas gur féidir linn an rialú a thabhairt ar ais don am rite. Ciallaíonn sé sin go
gceann muid rud éigin ar féidir linn fanacht leis!</p>
<p>Is féidir linn an cineál seo láimhseála a fheiceáil ag tarlú cheana féin i Liostáil 17-23: dá
mbaineamar an <code>trpl::sleep</code> ag deireadh thodhchaí <code>a</code>, chríochnódh sé
gan an todhchaí <code>b</code> ag rith <em>ar chor ar bith</em>. Déanaimis iarracht an fheidhm <code>sleep</code> a úsáid mar
phointe tosaigh chun ligean d'oibríochtaí múchadh agus dul chun cinn á dhéanamh, mar a thaispeántar i
Liostáil 17-24.</p>
<Listing number="17-24" caption="Using `sleep` to let operations switch off making progress" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 35);
            trpl::sleep(one_ms).await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>I Liosta 17-24, cuirimid glaonna <code>trpl::sleep</code> le pointí await idir gach glao le <code>slow</code>. Anois tá obair an dá thodhchaí fite fuaite:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-24
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p>Ritheann an todhchaí <code>a</code> ar feadh tamaill fós sula dtugann sé an smacht do <code>b</code>, mar gheall ar <code>slow</code> sula nglaonn sé ar <code>trpl::sleep</code> riamh, ach ina dhiaidh sin malartaíonn na todhchaí
ar ais agus amach gach uair a bhuaileann ceann acu pointe fanachta. Sa chás seo, rinneamar é sin tar éis gach glao ar <code>slow</code>, ach d'fhéadfaimis an obair a bhriseadh suas ar
cibé bealach is ciallmhaire dúinn.</p>
<p>Ní mian linn <em>sleep</em> anseo i ndáiríre, áfach: ba mhaith linn dul chun cinn a dhéanamh chomh tapa
agus is féidir linn. Ní mór dúinn ach an smacht a thabhairt ar ais don am rith. Is féidir linn é sin a dhéanamh
go díreach, ag baint úsáide as an bhfeidhm <code>yield_now</code>. I Liosta 17-25, cuirimid <code>yield_now</code> in ionad na nglaonna <code>sleep</code> sin go léir.</p>
<Listing number="17-25" caption="Using `yield_now` to let operations switch off making progress" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 35);
            trpl::yield_now().await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Tá an cód seo níos soiléire faoin aidhm iarbhír agus is féidir leis a bheith i bhfad níos tapúla ná <code>codladh</code> a úsáid, mar is minic a bhíonn teorainneacha ag lasc ama cosúil leis an gceann a úsáideann <code>codladh</code> maidir le cé chomh mionsonraithe is féidir leo a bheith. Codlaíonn an leagan de <code>codladh</code> atá á úsáid againn,
mar shampla, i gcónaí ar feadh milleasoicind ar a laghad, fiú má thugaimid <code>Fad</code> nana-soicind amháin dó. Arís, tá ríomhairí nua-aimseartha <em>tapa</em>: is féidir leo
go leor a dhéanamh i milleasoicind amháin!</p>
<p>Is féidir leat é seo a fheiceáil duit féin trí thagarmharc beag a shocrú, mar shampla an ceann
i Liostáil 17-26. (Ní bealach thar a bheith dian é seo chun tástáil feidhmíochta a dhéanamh,
ach is leor é chun an difríocht a thaispeáint anseo.)</p>
<Listing number="17-26" caption="Comparing the performance of `sleep` and `yield_now`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep' version finished after {} seconds.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield' version finished after {} seconds.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Anseo, scipeáilimid an priontáil stádais go léir, cuirimid <code>Duration</code> aon-nana-soicind chuig
<code>trpl::sleep</code>, agus ligimid do gach todhchaí rith leis féin, gan aon athrú idir na
todhchaí. Ansin rithimid ar feadh 1,000 athrá agus feicimid cé chomh fada a thógann an todhchaí ag baint úsáide as
<code>trpl::sleep</code> i gcomparáid leis an todhchaí ag baint úsáide as <code>trpl::yield_now</code>.</p>
<p>Tá an leagan le <code>yield_now</code> <em>i bhfad</em> níos tapúla!</p>
<p>Ciallaíonn sé seo gur féidir le haisioncrónú a bheith úsáideach fiú le haghaidh tascanna atá ceangailte le ríomh, ag brath ar
cad eile atá á dhéanamh ag do chlár, toisc go soláthraíonn sé uirlis úsáideach chun
na caidrimh idir codanna éagsúla den chlár a struchtúrú. Is
foirm <em>iltascála comhoibríoch</em> é seo, áit a bhfuil an chumhacht ag gach todhchaí a chinneadh
cathain a thugann sé smacht trí phointí feithimh. Dá bhrí sin, tá an
fhreagracht ar gach todhchaí freisin bac a sheachaint ar feadh ró-fhada. I roinnt córas oibriúcháin leabaithe bunaithe ar Rust,
is é seo an <em>t-aon</em> cineál iltascála!</p>
<p>I gcód an tsaoil réadaigh, ní bheidh tú ag malartú glaonna feidhme le pointí feithimh ar gach líne aonair de ghnáth, ar ndóigh. Cé go bhfuil sé réasúnta saor rialú a thabhairt ar an mbealach seo, níl sé saor in aisce. I go leor cásanna, d'fhéadfadh iarracht tasc atá ceangailte le ríomhaireacht a bhriseadh suas é a dhéanamh i bhfad níos moille, mar sin uaireanta is fearr
don fheidhmíocht fhoriomlán ligean d'oibríocht blocáil go hachomair. Déan
tomhais i gcónaí chun a fheiceáil cad iad na bacainní feidhmíochta iarbhír atá i do chód. Tá sé tábhachtach an
dinimic bhunúsach a choinneáil i gcuimhne, áfach, má <em>tá</em> tú ag feiceáil
go leor oibre ag tarlú i sraitheach a raibh súil agat a tharlódh ag an am céanna!</p>
<h3 id="Ár-naistarraingtí-aisioncrónacha-féin-a-thógáil"><a class="header" href="#Ár-naistarraingtí-aisioncrónacha-féin-a-thógáil">Ár nAistarraingtí Aisioncrónacha Féin a Thógáil</a></h3>
<p>Is féidir linn todhchaí a chumadh le chéile freisin chun patrúin nua a chruthú. Mar shampla, is féidir linn
feidhm 'am scoir' a thógáil le bloic thógála aisioncrónacha atá againn cheana féin. Nuair
a bheidh muid críochnaithe, beidh an toradh ina bhloc tógála eile a d'fhéadfaimis a úsáid chun
níos mó aistarraingtí aisioncrónacha a chruthú.</p>
<p>Léiríonn liostú 17-27 conas a bheimid ag súil go n-oibreodh an 'tréimhse scoir' seo le todhchaí mall.</p>
<p>Tá an cód seo níos soiléire faoin aidhm iarbhír agus is féidir leis a bheith i bhfad níos tapúla ná <code>codladh</code> a úsáid, mar is minic a bhíonn teorainneacha ag lasc ama cosúil leis an gceann a úsáideann <code>codladh</code> maidir le cé chomh mionsonraithe is féidir leo a bheith. Codlaíonn an leagan de <code>codladh</code> atá á úsáid againn,
mar shampla, i gcónaí ar feadh milleasoicind ar a laghad, fiú má thugaimid <code>Fad</code> nana-soicind amháin dó. Arís, tá ríomhairí nua-aimseartha <em>tapa</em>: is féidir leo
go leor a dhéanamh i milleasoicind amháin!</p>
<p>Is féidir leat é seo a fheiceáil duit féin trí thagarmharc beag a shocrú, mar shampla an ceann
i Liostáil 17-26. (Ní bealach thar a bheith dian é seo chun tástáil feidhmíochta a dhéanamh,
ach is leor é chun an difríocht a thaispeáint anseo.)</p>
<p>Priontálann gach todhchaí teachtaireacht nuair a thosaíonn sé ag rith, sosann sé ar feadh tamaill
trí ghlaoch agus fanacht le <code>sleep</code>, agus ansin priontálann sé teachtaireacht eile nuair a
chríochnaíonn sé. Ansin, cuirimid <code>slow</code> agus <code>fast</code> araon chuig <code>trpl::race</code> agus fanfaimid go gcríochnóidh ceann
dóibh. (Níl an toradh anseo ró-iontach: buaileann <code>fast</code>.) Murab ionann agus
nuair a d'úsáideamar <code>race</code> ar ais in <a href="ch17-01-futures-and-syntax.html#our-first-async-program">“Ár gCéad Chlár Asyncrónach”</a><!--
ignore -->, ní dhéanaimid ach neamhaird den chás <code>Either</code> a thugann sé ar ais anseo, toisc go dtarlaíonn an t-iompar suimiúil go léir i gcorp na mbloc asyncrónach.</p>
<p>Tabhair faoi deara má athraíonn tú ord na n-argóintí go <code>race</code>, athraíonn ord na
dteachtaireachtaí “tosaithe”, cé go gcríochnaíonn an todhchaí <code>fast</code> i gcónaí
ar dtús. Sin toisc nach bhfuil cur i bhfeidhm na feidhme <code>race</code> seo cothrom. Ritheann sé na todhchaí a chuirtear isteach mar argóintí i gcónaí san ord ina
ritheann siad. Tá cur i bhfeidhm eile <em>cóir</em> agus roghnóidh siad go randamach
cé acu todhchaí le vótaíocht ar dtús. Beag beann ar cibé an bhfuil cur i bhfeidhm an chine
atá á úsáid againn cothrom, áfach, rithfidh <em>ceann</em> de na todhchaí suas go dtí an chéad
<code>await</code> ina chorp sula bhféadfar tasc eile a thosú.</p>
<p>Meabhraigh ó <a href="ch17-01-futures-and-syntax.html#our-first-async-program">Ár gCéad Chlár Asyncrónach</a><!-- ignore --> go dtugann Rust deis d'am rith an tasc a chur ar sos agus aistriú go
ceann eile mura bhfuil an todhchaí atá á fanacht réidh. Tá an rud eile fíor freisin:
Cuireann Rust <em>only</em> sos ar bhloic asyncrónacha agus tugann sé an rialú ar ais go ham rith ag pointe feithimh.
Tá gach rud idir pointí feithimh sioncrónach.</p>
<p>Ciallaíonn sé sin má dhéanann tú go leor oibre i mbloc asyncrónach gan pointe feithimh,
go gcuirfidh an todhchaí sin bac ar aon todhchaí eile ó dhul chun cinn a dhéanamh. Uaireanta, d'fhéadfá
é seo a chloisteáil mar thodhchaí amháin ag <em>ocras</em> todhchaí eile. I gcásanna áirithe,
b'fhéidir nach mbeadh sé sin ina mhórcheist. Mar sin féin, má tá tú ag déanamh cineál éigin oibre costasaí
suite nó oibre fadtréimhseach, nó má tá todhchaí agat a leanfaidh ort ag déanamh tasc áirithe
go deo, beidh ort smaoineamh ar cathain agus cá háit le rialú a thabhairt ar ais don am rith.</p>
<p>Ar an gcaoi chéanna, má tá oibríochtaí blocála fadtréimhseacha agat, is féidir le haisioncrónach a bheith ina
uirlis úsáideach chun bealaí a sholáthar do chodanna éagsúla den chlár baint a bheith acu
le chéile.</p>
<p>Ach <em>conas</em> a thabharfá rialú ar ais don am rith sna cásanna sin?</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="yielding"></a></p>
<h3 id="rialú-a-thabhairt-don-am-rith-1"><a class="header" href="#rialú-a-thabhairt-don-am-rith-1">Rialú a Thabhairt don Am Rith</a></h3>
<p>Déanaimis oibríocht fhadtréimhseach a insamhladh. Tugann liostú 17-22 feidhm <code>slow</code> isteach.</p>
<Listing number="17-22" caption="Using `thread::sleep` to simulate slow operations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // We will call `slow` here later
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}</code></pre></pre>
</Listing>
<p>Úsáideann an cód seo <code>std::thread::sleep</code> in ionad <code>trpl::sleep</code> ionas go gcuirfidh glaoch ar <code>slow</code> bac ar an snáithe reatha ar feadh roinnt milleasoicindí. Is féidir linn <code>slow</code> a úsáid chun seasamh in ionad oibríochtaí fíorshaoil ​​atá ag rith ar feadh i bhfad agus
ag blocáil.</p>
<p>I Liosta 17-23, úsáidimid <code>slow</code> chun aithris a dhéanamh ar an gcineál seo oibre atá ceangailte le LAP i
béire todhchaí.</p>
<Listing number="17-23" caption="Using `thread::sleep` to simulate slow operations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finished.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Ar dtús, ní thugann gach todhchaí ach an rialú ar ais chuig an am rite <em>tar éis</em> roinnt oibríochtaí mall a dhéanamh. Má ritheann tú an cód seo, feicfidh tú an t-aschur seo:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23/
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>Mar atá lenár sampla níos luaithe, críochnaíonn <code>race</code> a luaithe is a bhíonn <code>a</code> críochnaithe.
Níl aon idirnascadh idir an dá thodhchaí, áfach. Déanann an todhchaí <code>a</code> a chuid oibre go léir go dtí go bhfanann an glao <code>trpl::sleep</code>, ansin déanann an todhchaí <code>b</code> a chuid oibre go léir go dtí go bhfanann a glao <code>trpl::sleep</code> féin, agus ar deireadh críochnaíonn an todhchaí <code>a</code>. Chun ligean don dá thodhchaí dul chun cinn a dhéanamh idir a gcuid tascanna mall, teastaíonn pointí feithimh uainn ionas gur féidir linn an rialú a thabhairt ar ais don am rite. Ciallaíonn sé sin go
gceann muid rud éigin ar féidir linn fanacht leis!</p>
<p>Is féidir linn an cineál seo láimhseála a fheiceáil ag tarlú cheana féin i Liostáil 17-23: dá
mbaineamar an <code>trpl::sleep</code> ag deireadh thodhchaí <code>a</code>, chríochnódh sé
gan an todhchaí <code>b</code> ag rith <em>ar chor ar bith</em>. Déanaimis iarracht an fheidhm <code>sleep</code> a úsáid mar
phointe tosaigh chun ligean d'oibríochtaí múchadh agus dul chun cinn á dhéanamh, mar a thaispeántar i
Liostáil 17-24.</p>
<Listing number="17-24" caption="Using `sleep` to let operations switch off making progress" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 35);
            trpl::sleep(one_ms).await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>I Liosta 17-24, cuirimid glaonna <code>trpl::sleep</code> le pointí await idir gach glao le <code>slow</code>. Anois tá obair an dá thodhchaí fite fuaite:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-24
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p>Ritheann an todhchaí <code>a</code> ar feadh tamaill fós sula dtugann sé an smacht do <code>b</code>, mar gheall ar <code>slow</code> sula nglaonn sé ar <code>trpl::sleep</code> riamh, ach ina dhiaidh sin malartaíonn na todhchaí
ar ais agus amach gach uair a bhuaileann ceann acu pointe fanachta. Sa chás seo, rinneamar é sin tar éis gach glao ar <code>slow</code>, ach d'fhéadfaimis an obair a bhriseadh suas ar
cibé bealach is ciallmhaire dúinn.</p>
<p>Ní mian linn <em>sleep</em> anseo i ndáiríre, áfach: ba mhaith linn dul chun cinn a dhéanamh chomh tapa
agus is féidir linn. Ní mór dúinn ach an smacht a thabhairt ar ais don am rite. Is féidir linn é sin a dhéanamh
go díreach, ag baint úsáide as an bhfeidhm <code>yield_now</code>. I Liosta 17-25, cuirimid <code>yield_now</code> in ionad na nglaonna <code>sleep</code> sin go léir.</p>
<Listing number="17-25" caption="Using `yield_now` to let operations switch off making progress" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 35);
            trpl::yield_now().await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Tá an cód seo níos soiléire faoin aidhm iarbhír agus is féidir leis a bheith i bhfad níos tapúla ná <code>sleep</code> a úsáid, mar is minic a bhíonn teorainneacha ag lasc ama cosúil leis an gceann a úsáideann <code>sleep</code> maidir le cé chomh mionsonraithe is féidir leo a bheith. Codlaíonn an leagan de <code>sleep</code> atá á úsáid againn,
mar shampla, i gcónaí ar feadh milleasoicind ar a laghad, fiú má thugaimid <code>Fad</code> nana-soicind amháin dó. Arís, tá ríomhairí nua-aimseartha <em>tapa</em>: is féidir leo
go leor a dhéanamh i milleasoicind amháin!</p>
<p>Is féidir leat é seo a fheiceáil duit féin trí thagarmharc beag a shocrú, mar shampla an ceann
i Liostáil 17-26. (Ní bealach thar a bheith dian é seo chun tástáil feidhmíochta a dhéanamh,
ach is leor é chun an difríocht a thaispeáint anseo.)</p>
<Listing number="17-26" caption="Comparing the performance of `sleep` and `yield_now`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep' version finished after {} seconds.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield' version finished after {} seconds.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Anseo, scipeáilimid an priontáil stádais go léir, cuirimid <code>Duration</code> aon-nana-soicind chuig
<code>trpl::sleep</code>, agus ligimid do gach todhchaí rith leis féin, gan aon athrú idir na
todhchaí. Ansin rithimid ar feadh 1,000 athrá agus feicimid cé chomh fada a thógann an todhchaí ag baint úsáide as
<code>trpl::sleep</code> i gcomparáid leis an todhchaí ag baint úsáide as <code>trpl::yield_now</code>.</p>
<p>Tá an leagan le <code>yield_now</code> <em>i bhfad</em> níos tapúla!</p>
<p>Ciallaíonn sé seo gur féidir le haisioncrónú a bheith úsáideach fiú le haghaidh tascanna atá ceangailte le ríomhairí, ag brath ar
cad eile atá á dhéanamh ag do chlár, toisc go soláthraíonn sé uirlis úsáideach chun
na caidrimh idir codanna éagsúla den chlár a struchtúrú. Is
foirm <em>iltascála comhoibríoch</em> é seo, áit a bhfuil an chumhacht ag gach todhchaí a chinneadh
cathain a thugann sé smacht trí phointí feithimh. Dá bhrí sin, tá an
fhreagracht ar gach todhchaí freisin bac a sheachaint ar feadh ró-fhada. I roinnt córas oibriúcháin leabaithe bunaithe ar Rust,
is é seo an <em>t-aon</em> cineál iltascála!</p>
<p>I gcód an tsaoil réadaigh, ní bheidh tú ag malartú glaonna feidhme le pointí feithimh ar gach líne aonair de ghnáth, ar ndóigh. Cé go bhfuil sé réasúnta saor rialú a thabhairt ar an mbealach seo, níl sé saor in aisce. I go leor cásanna, d'fhéadfadh iarracht tasc atá ceangailte le ríomhaireacht a bhriseadh suas é a dhéanamh i bhfad níos moille, mar sin uaireanta is fearr
don fheidhmíocht fhoriomlán ligean d'oibríocht blocáil go hachomair. Déan
tomhais i gcónaí chun a fheiceáil cad iad na bacainní feidhmíochta iarbhír atá i do chód. Tá sé tábhachtach an
dinimic bhunúsach a choinneáil i gcuimhne, áfach, má <em>tá</em> tú ag feiceáil
go leor oibre ag tarlú i sraitheach a raibh súil agat a tharlódh ag an am céanna!</p>
<h3 id="Ár-naistarraingtí-aisioncrónacha-féin-a-thógáil-1"><a class="header" href="#Ár-naistarraingtí-aisioncrónacha-féin-a-thógáil-1">Ár nAistarraingtí Aisioncrónacha Féin a Thógáil</a></h3>
<p>Is féidir linn todhchaí a chumadh le chéile freisin chun patrúin nua a chruthú. Mar shampla, is féidir linn
feidhm <code>timeout</code> a thógáil le bloic thógála aisioncrónacha atá againn cheana féin. Nuair
a bheidh muid críochnaithe, beidh an toradh ina bhloc tógála eile a d'fhéadfaimis a úsáid chun
níos mó aistarraingtí aisioncrónacha a chruthú.</p>
<p>Léiríonn liostú 17-27 conas a bheimid ag súil go n-oibreodh an <code>timeout</code> seo le todhchaí
mhall.</p>
<Listing number="17-27" caption="Using our imagined `timeout` to run a slow operation with a time limit" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "I finished!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Cuirimis seo i bhfeidhm! Chun tús a chur leis, smaoinímis ar an API don <code>timeout</code>:</p>
<ul>
<li>Caithfidh sé a bheith ina fheidhm neamhshioncrónach féin ionas gur féidir linn fanacht leis.</li>
<li>Ba chóir go mbeadh a chéad pharaiméadar ina thodhchaí le rith. Is féidir linn é a dhéanamh cineálach chun ligean dó oibriú le haon thodhchaí.</li>
<li>Is é an dara paraiméadar an t-uasmhéid ama le fanacht. Má úsáidimid <code>Duration</code>,
cuirfidh sé sin ar aghaidh go héasca chuig <code>trpl::sleep</code>.</li>
<li>Ba chóir dó <code>Result</code> a thabhairt ar ais. Má chríochnaíonn an todhchaí go rathúil, beidh an <code>Result</code> ina <code>Ok</code> leis an luach a tháirg an todhchaí. Má théann an t-am scoir thart ar dtús, beidh an <code>Result</code> ina <code>Err</code> leis an ré a d'fhan an t-am scoir leis.</li>
</ul>
<p>Taispeánann Liostáil 17-28 an dearbhú seo.</p>
<!-- This is not tested because it intentionally does not compile. -->
<Listing number="17-28" caption="Defining the signature of `timeout`" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Finally finished"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_millis(10)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Succeeded with '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Failed after {} seconds", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // Here is where our implementation will go!
}</code></pre>
</Listing>
<p>Sásaíonn sé sin ár spriocanna do na cineálacha. Anois smaoinímis ar an <em>iompar</em> atá de dhíth orainn: ba mhaith linn rás a dhéanamh idir an todhchaí a chuirtear isteach agus an fad ama. Is féidir linn <code>trpl::sleep</code> a úsáid chun todhchaí lasc ama a chruthú ón fad ama, agus <code>trpl::race</code> a úsáid chun
an lasc ama sin a rith leis an todhchaí a chuireann an glaoiteoir isteach.</p>
<p>Tá a fhios againn freisin nach bhfuil <code>race</code> cothrom, ag bailiú argóintí san ord ina
ritheann siad. Dá bhrí sin, cuirimid <code>future_to_try</code> chuig <code>race</code> ar dtús ionas go mbeidh
seans aige a chríochnú fiú má tá fad an-ghearr ag <code>max_time</code>. Má chríochnaíonn <code>future_to_try</code> ar dtús, cuirfidh <code>race</code> <code>Left</code> ar ais leis an aschur ó
<code>future_to_try</code>. Má chríochnaíonn <code>timer</code> ar dtús, cuirfidh <code>race</code> <code>Right</code> ar ais le
aschur an lasc ama de <code>()</code>.</p>
<p>I Liostáil 17-29, déanaimid meaitseáil ar thoradh fanacht le <code>trpl::race</code>.</p>
<Listing number="17-29" caption="Defining `timeout` with `race` and `sleep`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span>use trpl::Either;

// --snip--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finally finished"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
    });
}

async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Má éiríonn leis an <code>future_to_try</code> agus má fhaighimid <code>Left(output)</code>, cuirimid <code>Ok(output)</code> ar ais. Má théann an lasc ama codlata thart ina ionad sin agus má fhaighimid <code>Right(())</code>, déanaimid neamhaird den <code>()</code> le <code>_</code> agus cuirimid <code>Err(max_time)</code> ar ais ina ionad.</p>
<p>Leis sin, tá <code>timeout</code> oibre againn atá tógtha as dhá chúntóir neamhshioncrónach eile. Má
rithimid ár gcód, priontáilfidh sé an modh teipe tar éis an ama deiridh:</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p>Ós rud é go gcuireann todhchaí le chéile todhchaí eile, is féidir leat uirlisí an-chumhachtacha a thógáil
ag baint úsáide as bloic thógála níos lú neamhshioncrónacha. Mar shampla, is féidir leat an cur chuige céanna seo a úsáid
chun sosanna ama a chomhcheangal le hathiarrachtaí, agus iad sin a úsáid le hoibríochtaí ar nós
glaonna líonra (ceann de na samplaí ó thús na caibidle).</p>
<p>Go praiticiúil, is gnách go n-oibreoidh tú go díreach le <code>async</code> agus <code>await</code>, agus
sa dara háit le feidhmeanna agus macraí ar nós <code>join</code>, <code>join_all</code>, <code>race</code>, agus mar sin de. Ní bheidh ort ach teacht ar <code>pin</code> anois is arís chun todhchaí a úsáid leis na
APIanna sin.</p>
<p>Tá roinnt bealaí feicthe againn anois chun oibriú le todhchaí iolracha ag an am céanna.
An chéad rud eile, féachfaimid ar an gcaoi a bhféadfaimid oibriú le todhchaí iolracha i
seicheamh thar am le <em>streams</em>. Seo cúpla rud eile a d'fhéadfá a mheas ar dtús, áfach:</p>
<ul>
<li>
<p>D'úsáideamar <code>Vec</code> le <code>join_all</code> chun fanacht go gcríochnóidh na todhchaí go léir i ngrúpa éigin
le chéile. Conas a d'fhéadfá <code>Vec</code> a úsáid chun grúpa todhchaíochtaí a phróiseáil in ord ina ionad? Cad iad na comhbhabhtálacha a bhaineann leis sin a dhéanamh?</p>
</li>
<li>
<p>Féach ar an gcineál <code>futures::stream::FuturesUnordered</code> ón gcliathbhosca <code>futures</code>. Cén chaoi a mbeadh sé difriúil idir é a úsáid agus <code>Vec</code> a úsáid? (Ná bíodh imní ort faoin bhfíric go bhfuil sé ón gcuid <code>stream</code> den chliathbhosca; oibríonn sé go breá le haon bhailiúchán todhchaíochtaí.)</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-04-streams.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-02-concurrency-with-async.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-04-streams.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/css/ferris.js"></script>


    </div>
    </body>
</html>
