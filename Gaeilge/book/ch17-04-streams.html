<!DOCTYPE HTML>
<html lang="ga" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sruthanna - An Teanga Ríomhchláraithe Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/css/ferris.css">
        <link rel="stylesheet" href="src/css/2018-edition.css">
        <link rel="stylesheet" href="src/css/semantic-notes.css">
        <link rel="stylesheet" href="src/css/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">An Teanga Ríomhchláraithe Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/aindriu80/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="sruthanna-todhchaí-i-seicheamh"><a class="header" href="#sruthanna-todhchaí-i-seicheamh">Sruthanna: Todhchaí i Seicheamh</a></h2>
<!-- Seancheannteidil. Ná bain iad nó d'fhéadfadh naisc briseadh. -->
<p><a id="streams"></a></p>
<p>Go dtí seo sa chaibidil seo, táimid cloíte den chuid is mó le todhchaí aonair. Ba é an t-aon eisceacht mhór
a d'úsáideamar ná an cainéal asyncrónach. Cuimhnigh ar an gcaoi ar úsáideamar an glacadóir dár
chainéal asyncrónach níos luaithe sa chaibidil seo sa chuid <a href="ch17-02-concurrency-with-async.html#message-passing">“Teachtaireacht
Ag Pasáil”</a><!-- neamhaird -->. Táirgeann an modh async <code>recv</code>
seicheamh míreanna le himeacht ama. Is sampla é seo de phatrún i bhfad níos
ginearálta ar a dtugtar <em>stream</em>.</p>
<p>Chonaiceamar seicheamh míreanna siar i gCaibidil 13, nuair a d'fhéachamar ar an tréith <code>Iterator</code>
sa chuid <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">An Tréith Iterator agus an Modh <code>next</code></a><!-- neamhaird
-->, ach tá dhá dhifríocht idir atreoraitheoirí agus an glacadóir
cainéil asyncrónach. Is é an chéad difríocht ná am: bíonn athráiteoirí sioncrónach, agus
bíonn glacadóir an chainéil neamhshioncrónach. Is é an dara ceann an API. Agus muid ag obair
go díreach le <code>Iterator</code>, glaoimid ar a mhodh sioncrónach <code>next</code>. Leis an
sruth <code>trpl::Receiver</code> go háirithe, thugamar modh neamhshioncrónach <code>recv</code> air ina ionad. Seachas sin, mothaíonn na APIanna seo an-chosúil, agus ní comhtharlú é an chosúlacht sin. Tá sruth cosúil le foirm neamhshioncrónach athrá. Cé go
bhfuil an <code>trpl::Receiver</code> ag fanacht go sonrach le teachtaireachtaí a fháil, áfach, tá an
API srutha ginearálta i bhfad níos leithne: soláthraíonn sé an chéad mhír eile ar an
mbealach a dhéanann <code>Iterator</code>, ach go neamhshioncrónach.</p>
<p>Ciallaíonn an chosúlacht idir athráiteoirí agus sruthanna i Rust gur féidir linn
sruth a chruthú ó aon athráiteoir. Mar atá le hathráiteoir, is féidir linn oibriú le
sruth trí ghlaoch ar a mhodh <code>next</code> agus ansin fanacht leis an aschur, mar atá i Liostáil
17-30.</p>
<Listing number="17-30" caption="Creating a stream from an iterator and printing its values" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Tosaímid le sraith uimhreacha, a thiontóimid ina n-athráthóir agus ansin glaoimid ar <code>map</code> chun na luachanna go léir a dhúbailt. Ansin tiontóimid an t-athráthóir ina shruth
ag baint úsáide as an bhfeidhm <code>trpl::stream_from_iter</code>. Ansin, lúbaimid thar na míreanna sa
sruth de réir mar a thagann siad leis an lúb <code>while let</code>.</p>
<p>Ar an drochuair, nuair a dhéanaimid iarracht an cód a rith, ní thiomsaíonn sé, ach ina ionad sin tuairiscíonn sé nach bhfuil aon mhodh <code>next</code> ar fáil:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-30
cargo build
copy only the error output
-->
<pre><code class="language-console">error[E0599]: no method named `next` found for struct `Iter` in the current scope
  --&gt; src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = note: the full type name has been written to 'file:///projects/async_await/target/debug/deps/async_await-9de943556a6001b8.long-type-1281356139287206597.txt'
   = note: consider using `--verbose` to print the full type name to the console
   = help: items from traits can only be used if the trait is in scope
help: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: there is a method `try_next` with a similar name
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
</code></pre>
<p>Mar a mhíníonn an t-aschur seo, is é an chúis atá leis an earráid tiomsaitheora ná go bhfuil an tréith cheart sa raon feidhme ag teastáil uainn chun an modh <code>next</code> a úsáid. Agus ár bplé
go dtí seo san áireamh, d'fhéadfá a bheith ag súil go réasúnta gurb é <code>Stream</code> an tréith sin, ach is é <code>StreamExt</code> atá ann i ndáiríre. Giorrúchán do <em>extension</em>, is patrún coitianta é <code>Ext</code> i
bphobal Rust chun tréith amháin a shíneadh le tréith eile.</p>
<p>Mínímid na tréithe <code>Stream</code> agus <code>StreamExt</code> beagán níos mine ag
deireadh na caibidle, ach faoi láthair níl le fios agat ach go sainmhíníonn an tréith <code>Stream</code>
comhéadan ísealleibhéil a chomhcheanglaíonn na tréithe <code>Iterator</code> agus
<code>Future</code> go héifeachtach. Soláthraíonn <code>StreamExt</code> sraith APIanna ardleibhéil ar bharr
<code>Stream</code>, lena n-áirítear an modh <code>next</code> chomh maith le modhanna fóntais eile cosúil
leis na cinn a sholáthraíonn an tréith <code>Iterator</code>. Níl <code>Stream</code> agus <code>StreamExt</code>
mar chuid de leabharlann chaighdeánach Rust fós, ach úsáideann formhór na gcliathbhoscaí éiceachórais an sainmhíniú céanna.</p>
<p>Is é an réiteach ar an earráid tiomsaitheora ná ráiteas <code>use</code> a chur leis le haghaidh <code>trpl::StreamExt</code>,
mar atá i Liostáil 17-31.</p>
<Listing number="17-31" caption="Successfully using an iterator as the basis for a stream" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
    });
}</code></pre></pre>
</Listing>
<p>Agus na píosaí sin go léir curtha le chéile, oibríonn an cód seo mar is mian linn! Ina theannta sin, anois go bhfuil <code>StreamExt</code> againn, is féidir linn a chuid modhanna fóntais go léir a úsáid, díreach mar a dhéantar le hathraitheoirí. Mar shampla, i Liosta 17-32, úsáidimid an modh <code>filter</code> chun gach rud a scagadh amach ach amháin iolraithe de thrí agus cúig.</p>
<Listing number="17-32" caption="Filtering a stream with the `StreamExt::filter` method" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = 1..101;
        let iter = values.map(|n| n * 2);
        let stream = trpl::stream_from_iter(iter);

        let mut filtered =
            stream.filter(|value| value % 3 == 0 || value % 5 == 0);

        while let Some(value) = filtered.next().await {
            println!("The value was: {value}");
        }
    });
}</code></pre></pre>
</Listing>
<p>Ar ndóigh, níl sé seo an-suimiúil, ós rud é go bhféadfaimis an rud céanna a dhéanamh le hathráiteoirí gnáth agus gan aon neamhshioncrónú ar chor ar bith. Féachfaimid ar a
is féidir linn a dhéanamh atá <em>uathúil</em> do shruthanna.</p>
<h3 id="sruthanna-a-chumadh"><a class="header" href="#sruthanna-a-chumadh">Sruthanna a Chumadh</a></h3>
<p>Léirítear go leor coincheap go nádúrtha mar shruthanna: míreanna ag teacht ar fáil i
scuaine, píosaí sonraí á dtarraingt de réir a chéile ón gcóras comhad nuair a bhíonn an
tacar sonraí iomlán ró-mhór do thacar sonraí an ríomhaire, nó sonraí ag teacht thar an
líonra le himeacht ama. Ós rud é gur todhchaí iad sruthanna, is féidir linn iad a úsáid le haon
chineál eile todhchaí agus iad a chomhcheangal ar bhealaí suimiúla. Mar shampla, is féidir linn imeachtaí a bhaisc
chun an iomarca glaonna líonra a sheachaint, sosanna ama a shocrú ar sheichimh
oibríochtaí fada, nó imeachtaí comhéadain úsáideora a thógadh chun obair
gan ghá a sheachaint.</p>
<p>Tosaímis trí shruth beag teachtaireachtaí a thógáil mar ionadaí do shruth
sonraí a d'fhéadfaimis a fheiceáil ó WebSocket nó ó phrótacal cumarsáide fíor-ama eile, mar a thaispeántar i Liostáil 17-33.</p>
<Listing number="17-33" caption="Using the `rx` receiver as a `ReceiverStream`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages = get_messages();

        while let Some(message) = messages.next().await {
            println!("{message}");
        }
    });
}

fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for message in messages {
        tx.send(format!("Message: '{message}'")).unwrap();
    }

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>Ar dtús, cruthaímid feidhm ar a dtugtar <code>get_messages</code> a thugann <code>impl Stream&lt;Item = String&gt;</code> ar ais. Chun é a chur i bhfeidhm, cruthaímid cainéal neamhshioncrónach, lúbaimid thar na chéad 10 litir den aibítir Béarla, agus seolaimid iad trasna an chainéil.</p>
<p>Úsáidimid cineál nua freisin: <code>ReceiverStream</code>, a athraíonn an glacadóir <code>rx</code> ón <code>trpl::channel</code> go <code>Stream</code> le modh <code>next</code>. Ar ais i <code>main</code>, úsáidimid lúb <code>while let</code> chun na teachtaireachtaí go léir ón sruth a phriontáil.</p>
<p>Nuair a ritheann muid an cód seo, faighimid na torthaí go díreach a mbeimid ag súil leo:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Message: 'a'
Message: 'b'
Message: 'c'
Message: 'd'
Message: 'e'
Message: 'f'
Message: 'g'
Message: 'h'
Message: 'i'
Message: 'j'
</code></pre>
<p>Arís, d’fhéadfaimis é seo a dhéanamh leis an ngnáth-API <code>Receiver</code> nó fiú leis an ngnáth-API <code>Iterator</code>, áfach, mar sin cuirfimid gné leis a éilíonn sruthanna: ag cur teorainn ama leis a bhaineann le gach mír sa sruth, agus moill ar na míreanna a astaíonn muid, mar a thaispeántar i Liostáil 17-34.</p>
<Listing number="17-34" caption="Using the `StreamExt::timeout` method to set a time limit on the items in a stream" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages =
            pin!(get_messages().timeout(Duration::from_millis(200)));

        while let Some(result) = messages.next().await {
            match result {
                Ok(message) =&gt; println!("{message}"),
                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
            }
        }
    })
}
<span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">    for message in messages {
</span><span class="boring">        tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>We start by adding a timeout to the stream with the <code>timeout</code> method, which
comes from the <code>StreamExt</code> trait. Then we update the body of the <code>while let</code>
loop, because the stream now returns a <code>Result</code>. The <code>Ok</code> variant indicates a
message arrived in time; the <code>Err</code> variant indicates that the timeout elapsed
before any message arrived. We <code>match</code> on that result and either print the
message when we receive it successfully or print a notice about the timeout.
Finally, notice that we pin the messages after applying the timeout to them,
because the timeout helper produces a stream that needs to be pinned to be
polled.</p>
<p>However, because there are no delays between messages, this timeout does not
change the behavior of the program. Let’s add a variable delay to the messages
we send, as shown in Listing 17-35.</p>
<Listing number="17-35" caption="Sending messages through `tx` with an async delay without making `get_messages` an async function" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            tx.send(format!("Message: '{message}'")).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>I <code>get_messages</code>, úsáidimid an modh athrá <code>enumerate</code> leis an eagar <code>messages</code> ionas gur féidir linn innéacs gach míre atá á sheoladh againn a fháil mar aon leis an
mír féin. Ansin cuirimid moill 100 milleasoicind i bhfeidhm ar mhíreanna cothrom-innéacs agus moill 300 milleasoicind ar mhíreanna corr-innéacs chun na moilleanna éagsúla a d'fhéadfaimis a fheiceáil ó shruth teachtaireachtaí sa saol réadúil a insamhladh. Ós rud é go bhfuil ár n-am scoir
do 200 milleasoicind, ba cheart go mbeadh tionchar aige seo ar leath na dteachtaireachtaí.</p>
<p>Chun codladh idir theachtaireachtaí sa fheidhm <code>get_messages</code> gan bac a chur,
ní mór dúinn async a úsáid. Mar sin féin, ní féidir linn <code>get_messages</code> féin a dhéanamh ina fheidhm async,
mar ansin chuirfimis <code>Future&lt;Output = Stream&lt;Item = String&gt;&gt;</code> ar ais in ionad <code>Stream&lt;Item = String&gt;&gt;</code>. Bheadh ​​ar an nglaoiteoir fanacht
le <code>get_messages</code> féin chun rochtain a fháil ar an sruth. Ach cuimhnigh: tarlaíonn gach rud i
dtodhchaí ar leith go líneach; tarlaíonn comhthráthacht idir todhchaí. Dá mbeadh fanacht
le <code>get_messages</code> ann, bheadh ​​air na teachtaireachtaí go léir a sheoladh, lena n-áirítear an mhoill codlata
idir gach teachtaireacht, sula bhfillfí an sruth glacadóra. Mar thoradh air sin,
bheadh ​​an t-am scoir gan úsáid. Ní bheadh ​​aon mhoilleanna sa sruth féin;
tharlódh siad go léir sula mbeadh an sruth ar fáil fiú.</p>
<p>Ina áit sin, fágaimid <code>get_messages</code> mar fheidhm rialta a thugann sruth ar ais,
agus cruthaímid tasc chun na glaonna <code>sleep</code> neamhshioncrónacha a láimhseáil.</p>
<blockquote>
<p>Nóta: Oibríonn glaoch ar <code>spawn_task</code> ar an mbealach seo toisc go bhfuil ár
ham rithe socraithe againn cheana féin; mura mbeadh, chuirfeadh sé scaoll faoi deara. Roghnaíonn cur i bhfeidhm eile
comhbhabhtálacha difriúla: d'fhéadfadh siad am rithe nua a chruthú agus an scaoll a sheachaint ach
críochnóidh siad le beagán forchostais bhreise, nó d'fhéadfadh sé nach soláthróidh siad bealach
neamhspleách chun tascanna a chruthú gan tagairt d'am rithe. Bí cinnte go bhfuil a fhios agat
cén chomhréiteach atá roghnaithe ag do rith-am agus scríobh do chód dá réir!</p>
</blockquote>
<p>Anois tá toradh i bhfad níos suimiúla ag ár gcód. Idir gach péire eile
teachtaireachta, earráid <code>Problem: Elapsed(())</code>.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-35
cargo run
copy only the program output, *not* the compiler output
-->
<pre><code class="language-text">Message: 'a'
Problem: Elapsed(())
Message: 'b'
Message: 'c'
Problem: Elapsed(())
Message: 'd'
Message: 'e'
Problem: Elapsed(())
Message: 'f'
Message: 'g'
Problem: Elapsed(())
Message: 'h'
Message: 'i'
Problem: Elapsed(())
Message: 'j'
</code></pre>
<p>Ní chuireann an t-am scoir cosc ​​ar na teachtaireachtaí teacht sa deireadh. Faighimid fós
na teachtaireachtaí bunaidh go léir, mar go bhfuil ár gcainéal <em>gan teorainn</em>: is féidir leis an oiread
teachtaireachtaí agus is féidir linn a fheistiú sa chuimhne a shealbhú. Mura dtagann an teachtaireacht roimh an
am scoir, cuirfidh ár láimhseálaí srutha san áireamh é sin, ach nuair a dhéanann sé suirbhé ar an sruth
arís, d'fhéadfadh an teachtaireacht a bheith tagtha anois.</p>
<p>Is féidir leat iompar difriúil a fháil más gá trí chineálacha eile cainéal nó
cineálacha eile sruthanna a úsáid go ginearálta. Féachfaimid ar cheann acu sin i gcleachtas trí
shruth eatraimh ama a chomhcheangal leis an sruth teachtaireachtaí seo.</p>
<h3 id="sruthanna-a-chumasc"><a class="header" href="#sruthanna-a-chumasc">Sruthanna a Chumasc</a></h3>
<p>Ar dtús, cruthaímis sruth eile, a scaoilfidh mír gach milleasoicind má
ligimid dó rith go díreach. Ar mhaithe le simplíocht, is féidir linn an fheidhm <code>sleep</code> a úsáid chun
teachtaireacht a sheoladh ar mhoill agus í a chomhcheangal leis an gcur chuige céanna a d'úsáideamar i
<code>get_messages</code> chun sruth a chruthú ó chainéal. Is é an difríocht ná go seolfaimid ar ais an comhaireamh eatraimh atá caite an uair seo, mar sin beidh an cineál tuairisceáin <code>impl Stream&lt;Item = u32&gt;</code>, agus is féidir linn glaoch ar an bhfeidhm <code>get_intervals</code> (féach Liostáil 17-36).</p>
<Listing number="17-36" caption="Creating a stream with a counter that will be emitted once every millisecond" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;
            tx.send(count).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>Tosaímid trí <code>count</code> a shainiú sa tasc. (D'fhéadfaimis é a shainiú lasmuigh den
tasc freisin, ach is soiléire raon feidhme aon athróg ar leith a theorannú.) Ansin
cruthaímid lúb gan teorainn. Codlaíonn gach athrá den lúb go haisioncrónach ar feadh
milleasoicind amháin, méadaíonn sé an comhaireamh, agus ansin seolann sé thar an gcainéal é.
Toisc go bhfuil sé seo go léir fillte sa tasc a chruthaigh <code>spawn_task</code>, glanfar suas é go léir - lena n-áirítear an lúb gan teorainn - mar aon leis an am rith.</p>
<p>Tá an cineál seo lúb gan teorainn, nach gcríochnaíonn ach amháin nuair a dhéantar an t-am rith iomlán a stróiceadh, sách coitianta i meirge asyncrónach: ní mór do go leor clár leanúint ar aghaidh ag rith
go neamhchinnte. Le haisioncrónach, ní chuireann sé seo bac ar aon rud eile, fad is atá
pointe feithimh amháin ar a laghad i ngach athrá tríd an lúb.</p>
<p>Anois, ar ais i mbloc asyncrónach ár bpríomhfheidhme, is féidir linn iarracht a dhéanamh na sruthanna
<code>messages</code> agus <code>intervals</code> a chumasc, mar a thaispeántar i Liostáil 17-37.</p>
<Listing number="17-37" caption="Attempting to merge the `messages` and `intervals` streams" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals();
        let merged = messages.merge(intervals);
<span class="boring">
</span><span class="boring">        while let Some(result) = merged.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Tosaímid trí ghlaoch ar <code>get_intervals</code>. Ansin, déanaimid na sruthanna <code>messages</code> agus <code>intervals</code> a chumasc leis an modh <code>merge</code>, a chomhcheanglaíonn ilshruthanna
i sruth amháin a tháirgeann míreanna ó aon cheann de na sruthanna foinse a luaithe
a bhíonn na míreanna ar fáil, gan aon ordú ar leith a fhorchur. Ar deireadh, déanaimid lúb thar an sruth comhcheangailte sin in ionad thar <code>messages</code>.</p>
<p>Ag an bpointe seo, ní gá <code>messages</code> ná <code>intervals</code> a phionáil ná a athrú,
toisc go gcomhcheanglófar an dá cheann sa sruth <code>merged</code> aonair. Mar sin féin, ní
thiomsaíonn an glao seo chun <code>merge</code>! (Ní dhéanann an glao <code>next</code> sa lúb <code>while let</code> ach an oiread, ach fillfimid ar sin.) Tá sé seo amhlaidh toisc go bhfuil
cineálacha difriúla ag an dá shruth. Tá an cineál <code>Timeout&lt;impl Stream&lt;Item = String&gt;&gt;</code> ag an sruth <code>messages</code>, áit a bhfuil <code>Timeout</code> an cineál a chuireann <code>Stream</code> i bhfeidhm le haghaidh glao <code>timeout</code>. Tá an cineál <code>impl Stream&lt;Item = u32&gt;</code> ag an sruth <code>intervals</code>. Chun an dá shruth seo a chumasc, ní mór dúinn ceann acu a chlaochlú chun go n-oireann sé don cheann eile. Déanfaimid
athoibriú ar an sruth eatraimh, mar go bhfuil teachtaireachtaí cheana féin san fhormáid bhunúsach atá uainn agus caithfidh sé earráidí ama scoir a láimhseáil (féach Liostáil 17-38).</p>
<!-- We cannot directly test this one, because it never stops. -->
<Listing number="17-38" caption="Aligning the type of the the `intervals` stream with the type of the `messages` stream" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}"))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Ar dtús, is féidir linn an modh cúnta <code>map</code> a úsáid chun na <code>intervals</code> a chlaochlú go
teaghrán. Ar an dara dul síos, ní mór dúinn an <code>Timeout</code> ó <code>messages</code> a mheaitseáil. Ós rud é nach bhfuilimid
i ndáiríre <em>ag iarraidh</em> teorainn ama do <code>intervals</code>, áfach, is féidir linn teorainn ama a chruthú
atá níos faide ná na tréimhsí eile atá á n-úsáid againn. Anseo, cruthaímid
tréimhse ama 10 soicind le <code>Duration::from_secs(10)</code>. Ar deireadh, ní mór dúinn
<code>stream</code> a dhéanamh inathraithe, ionas gur féidir le glaonna <code>next</code> an lúb <code>while let</code> athrá
tríd an sruth, agus é a phionáil ionas go mbeidh sé sábháilte é sin a dhéanamh. Tugann sé sin <em>beagnach</em>
sinn go dtí an áit a gcaithfimid a bheith. Seiceálann gach cineál. Má ritheann tú é seo, áfach,
beidh dhá fhadhb ann. Ar dtús, ní stopfaidh sé choíche! Beidh ort é a stopadh le
<span class="keystroke">ctrl-c</span>. Ar an dara dul síos, beidh na teachtaireachtaí ón aibítir Béarla curtha i measc na dteachtaireachtaí uile maidir le comhaireamh eatraimh:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the tasks running differently rather than
changes in the compiler -->
<pre><code class="language-text">--snip--
Interval: 38
Interval: 39
Interval: 40
Message: 'a'
Interval: 41
Interval: 42
Interval: 43
--snip--
</code></pre>
<p>Taispeánann liostú 17-39 bealach amháin chun an dá fhadhb dheireanacha seo a réiteach.</p>
<Listing number="17-39" caption="Using `throttle` and `take` to manage the merged streams" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}"))
            .throttle(Duration::from_millis(100))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals).take(20);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Ar dtús, úsáidimid an modh <code>throttling</code> ar an sruth <code>intervals</code> ionas nach gcuirfidh sé ró-ualach ar an sruth <code>messages</code>. Is bealach é <em>Throttling</em> chun an ráta a theorannú ag
a nglaofar ar fheidhm—nó, sa chás seo, cé chomh minic a dhéanfar an sruth a
phoibliú. Ba chóir go ndéanfadh uair amháin gach 100 milleasoicind, mar sin cé chomh minic
a thagann ár dteachtaireachtaí.</p>
<p>Chun líon na míreanna a nglacfaimid ó shruth a theorannú, cuirimid an modh <code>take</code> i bhfeidhm ar an sruth <code>merged</code>, mar ba mhaith linn an t-aschur deiridh a theorannú, ní hamháin sruth amháin nó an sruth eile.</p>
<p>Anois nuair a ritheann muid an clár, stopann sé tar éis 20 mír a tharraingt ón sruth,
agus ní chuireann na eatraimh ró-ualach ar na teachtaireachtaí. Ní fhaighimid <code>Interval: 100</code> ná <code>Interval: 200</code> nó mar sin de ach an oiread, ach ina ionad sin faighimid <code>Interval: 1</code>, <code>Interval: 2</code>,
agus mar sin de—cé go bhfuil sruth foinse againn ar féidir leis imeacht a tháirgeadh gach
mileasoicind. Sin toisc go dtáirgeann an glao <code>throttle</code> sruth nua a fhilleann
an sruth bunaidh ionas nach ndéantar poll ar an sruth bunaidh ach ag an ráta
scóip, ní ag a ráta "dúchasach" féin. Níl bunch teachtaireachtaí eatraimh neamhláimhseáilte againn
atá á roghnú againn neamhaird a dhéanamh orthu. Ina áit sin, ní tháirgimid na teachtaireachtaí eatraimh sin riamh sa chéad áit! Seo an "leisciúlacht" dúchasach de thodhchaí Rust
ag obair arís, rud a ligeann dúinn ár dtréithe feidhmíochta a roghnú.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-39
cargo run
copy and paste only the program output
-->
<pre><code class="language-text">Interval: 1
Message: 'a'
Interval: 2
Interval: 3
Problem: Elapsed(())
Interval: 4
Message: 'b'
Interval: 5
Message: 'c'
Interval: 6
Interval: 7
Problem: Elapsed(())
Interval: 8
Message: 'd'
Interval: 9
Message: 'e'
Interval: 10
Interval: 11
Problem: Elapsed(())
Interval: 12
</code></pre>
<p>Tá rud amháin eile ann a chaithfimid a láimhseáil: earráidí! Leis an dá shruth seo atá bunaithe ar chainéal, d'fhéadfadh na glaonna <code>send</code> teip nuair a dhúnann an taobh eile den
chainéal—agus níl ansin ach ceist faoin gcaoi a ndéanann an t-am rith na todhchaí a fhorghníomhú
a dhéanann suas an sruth. Go dtí seo, níor thugamar aird ar an bhféidearthacht seo trí ghlaoch ar
<code>unwrap</code>, ach in aip dea-iompartha, ba cheart dúinn an earráid a láimhseáil go sainráite, ar a laghad tríd an lúb a chríochnú ionas nach ndéanaimid iarracht aon teachtaireachtaí eile a sheoladh. Taispeánann liostú
17-40 straitéis earráide simplí: priontáil an cheist agus ansin <code>break</code> ó na
lúba.</p>
<Listing number="17-40" caption="Handling errors and shutting down the loops">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Interval #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];

        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            if let Err(send_error) = tx.send(format!("Message: '{message}'")) {
                eprintln!("Cannot send message '{message}': {send_error}");
                break;
            }
        }
    });

    ReceiverStream::new(rx)
}

fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>Mar is gnách, beidh an bealach ceart chun déileáil le hearráid seolta teachtaireachta éagsúil; déan cinnte go bhfuil straitéis agat.</p>
<p>Anois go bhfuil go leor neamhshioncrónacha feicthe againn i gcleachtas, déanaimis céim siar agus déanaimis tochailt isteach i roinnt de na sonraí faoi conas a úsáideann <code>Future</code>, <code>Stream</code>, agus na príomhthréithe eile a úsáideann Rust chun neamhshioncrón a chur ag obair.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-03-more-futures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-05-traits-for-async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-03-more-futures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-05-traits-for-async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/css/ferris.js"></script>


    </div>
    </body>
</html>
