<!DOCTYPE HTML>
<html lang="ga" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modh Comhréir - An Teanga Ríomhchláraithe Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/css/ferris.css">
        <link rel="stylesheet" href="src/css/2018-edition.css">
        <link rel="stylesheet" href="src/css/semantic-notes.css">
        <link rel="stylesheet" href="src/css/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">An Teanga Ríomhchláraithe Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/aindriu80/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="comhréir-modh"><a class="header" href="#comhréir-modh">Comhréir Modh</a></h2>
<p>Tá <em>modhanna</em> cosúil le feidhmeanna: dearbhaímid iad leis an eochairfhocal <code>fn</code> agus a
ainm, is féidir paraiméadair agus luach tuairisceáin a bheith acu, agus tá roinnt cód iontu
sin a rith nuair a ghlaoitear an modh ó áit éigin eile. Murab ionann agus feidhmeanna,
sainmhínítear modhanna i gcomhthéacs struchtúir (nó enum nó trait
réad, a chlúdaímid i <a href="ch06-00-enums.html">Caibidil 6</a> <!-- neamhaird --> agus <a href="ch18-02-trait-objects.html">Caibidil
17</a><!-- déan neamhaird de -->, faoi seach), agus is é a gcéad pharaiméadar
i gcónaí <code>self</code>, a léiríonn an ásc ar an struchtúr an modh á
ar a dtugtar ar.</p>
<h3 id="modhanna-a-shainmhíniú"><a class="header" href="#modhanna-a-shainmhíniú">Modhanna a Shainmhíniú</a></h3>
<p>Athraímis an fheidhm <code>area</code> a bhfuil sampla <code>Rectangle</code> aici mar pharaiméadar
agus ina ionad sin déan modh <code>area</code> atá sainmhínithe ar an struchtúr <code>Rectangle</code>, mar a thaispeántar
i Liosta 5-13.</p>
<Listing number="5-13" file-name="src/main.rs" caption="Defining an `area` method on the `Rectangle` struct">
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}</code></pre></pre>
</Listing>
<p>Chun an fheidhm a shainiú laistigh de chomhthéacs <code>Rectangle</code>, cuirimid tús le <code>impl</code>
(cur i bhfeidhm) bloc le haghaidh <code>Rectangle</code>. Gach rud laistigh den bhloc <code>impl</code> seo
a bhaineann leis an gcineál <code>Rectangle</code>. Ansin bogaimid an fheidhm <code>area</code>
laistigh de na lúibíní chatach <code>impl</code> agus athraigh an chéad cheann (agus sa chás seo, amháin)
paraiméadar a bheith <code>self</code> sa síniú agus i ngach áit laistigh den chorp. I
<code>main</code>, áit ar thugamar an fheidhm <code>area</code> agus gur ritheamar <code>rect1</code> mar argóint,
ina ionad sin is féidir linn <em>method syntax</em> a úsáid chun an modh <code>area</code> a ghlaoch ar ár <code>Rectangle</code>
shampla. Téann an modh comhréire tar éis sampla: cuirimid ponc leis ina dhiaidh sin
ainm an mhodha, lúibíní, agus aon argóintí.</p>
<p>Sa síniú le haghaidh <code>area</code>, úsáidimid <code>&amp;self</code> in ionad <code>rectangle: &amp;Rectangle</code>.
Tá an <code>&amp;self</code> gearr i ndáiríre do <code>self: &amp;Self</code>. Laistigh de bhloc <code>impl</code>, tá an
cineál Is ailias é <code>self</code> don chineál ar a bhfuil an bloc <code>impl</code>. Ní mór modhanna
bíodh paraiméadar darb ainm <code>self</code> den chineál <code>self</code> acu dá gcéad pharaiméadar, mar sin Meirge
ligeann sé duit é seo a ghiorrú gan ach an t-ainm <code>self</code> sa chéad láthair paraiméadar.
Tabhair faoi deara go gcaithfimid fós an <code>&amp;</code> a úsáid os comhair na gearrscaireachta <code>self</code> chun
cuir in iúl go bhfaigheann an modh seo an sampla <code>self</code> ar iasacht, díreach mar a rinneamar i
<code>rectangle: &amp;Rectangle</code>. Is féidir le modhanna úinéireacht a ghlacadh ar <code>self</code>, <code>self</code> a fháil ar iasacht
go do-athraithe, mar atá déanta againn anseo, nó 'self` a fháil ar iasacht go frithpháirteach, díreach mar is féidir leo
paraiméadar eile.</p>
<p>Roghnaigh muid <code>&amp;self</code> anseo ar an gcúis chéanna a d'úsáid muid <code>&amp;Rectangle</code> san fheidhm
leagan: nílimid ag iarraidh úinéireacht a ghlacadh, agus níl uainn ach na sonraí a léamh isteach
an struct, ní scríobh air. Dá mba mhian linn an cás atá againn a athrú
ar a dtugtar an modh ar mar chuid de cad a dhéanann an modh, d'úsáidfimid <code>&amp;mut self</code> mar
an chéad pharaiméadar. Ag modh a ghlacann úinéireacht ar an gcás trí
ag baint úsáide as ach <code>self</code> mar go bhfuil an chéad paraiméadar annamh; tá an teicníc seo de ghnáth
a úsáidtear nuair a athraíonn an modh <code>self</code> isteach i rud éigin eile agus is mian leat a
cosc a chur ar an nglaoiteoir an t-ábhar bunaidh a úsáid tar éis an chlaochlaithe.</p>
<p>An phríomhchúis le modhanna a úsáid in ionad feidhmeanna, sa bhreis ar
ag soláthar comhréire modhanna agus gan a bheith athrá ar an gcineál <code>self</code> i ngach
síniú an mhodha, is don eagraíocht é. Chuireamar gach rud is féidir linn a dhéanamh
le sampla de chineál i mbloc <code>impl</code> amháin seachas úsáideoirí a dhéanamh amach anseo
dár gcuardach cód le haghaidh cumais <code>Rectangle</code> in áiteanna éagsúla sa
leabharlann a chuirimid ar fáil.</p>
<p>Tabhair faoi deara gur féidir linn a roghnú modh a thabhairt ar an ainm céanna le ceann de na struchtúir
réimsí. Mar shampla, is féidir linn modh a shainiú ar <code>Rectangle</code> atá ainmnithe freisin
<code>width</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}</code></pre></pre>
</Listing>
<p>Anseo, táimid ag roghnú an modh <code>width</code> a thabhairt ar ais <code>true</code> má tá an luach isteach
tá réimse <code>width</code> an ásc níos mó ná <code>0</code> agus <code>false</code> más luach é
<code>0</code>: is féidir linn réimse a úsáid laistigh de mhodh den ainm céanna chun críche ar bith. I
<code>main</code>, nuair a leanaimid <code>rect1.width</code> le lúibíní, tá a fhios ag Rust gurb éard atá i gceist againn
modh <code>width</code>. Nuair nach n-úsáidimid lúibíní, tá a fhios ag Rust go bhfuil an réimse i gceist againn
<code>width</code>.</p>
<p>Go minic, ach ní i gcónaí, nuair a thugaimid modh an t-ainm céanna le réimse ba mhaith linn
é a thabhairt ar ais ach an luach sa réimse agus rud ar bith eile a dhéanamh. Modhanna mar seo
Tugtar <em>getters</em> orthu, agus ní chuireann Rust i bhfeidhm iad go huathoibríoch le haghaidh struchtúr
réimsí mar a dhéanann roinnt teangacha eile. Tá getters úsáideach mar is féidir leat an
réimse príobháideach ach an modh poiblí, agus dá bhrí sin cumasaigh rochtain inléite amháin air sin
réimse mar chuid den chineál API poiblí. Déanfaimid plé ar cad poiblí agus príobháideach
atá agus conas réimse nó modh a ainmniú mar phoiblí nó príobháideach i <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">Caibidil
7</a> <!-- neamhaird a dhéanamh -->.</p>
<blockquote>
<h3 id="cá-bhfuil-an-t-oibreoir--"><a class="header" href="#cá-bhfuil-an-t-oibreoir--">Cá bhfuil an t-oibreoir <code>-&gt;</code>?</a></h3>
<p>In C agus C++, úsáidtear dhá oibreoir éagsúla chun modhanna glaonna a úsáid: úsáideann tú
<code>.</code> má tá tú ag glaoch modh ar an réad go díreach agus <code>-&gt;</code> má tá tú
an modh a ghlaoch ar phointeoir don réad agus is gá díthagairt a dhéanamh don
pointeoir ar dtús. I bhfocail eile, más pointeoir é <code>object</code>,
Tá <code>object-&gt;something()</code> cosúil le <code>(*object).something()</code>.</p>
<p>Níl coibhéis ag meirge leis an oibreoir <code>-&gt;</code>; ina ionad sin, tá Rust a
gné ar a dtugtar <em>tagairtí uathoibríocha agus dereferencing</em>. Tá modhanna glaonna
ceann de na cúpla áit i Rust leis an iompar seo.</p>
<p>Seo mar a oibríonn sé: nuair a ghlaonn tú ar mhodh le <code>object.something()</code>, Rust
cuireann sé isteach <code>&amp;</code>, <code>&amp;mut</code>, nó <code>*</code> go huathoibríoch ionas go meaitseálann <code>object</code> síniú
an modh. I bhfocail eile, tá na rudaí seo a leanas mar an gcéanna:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>Breathnaíonn an chéad cheann i bhfad níos glaine. Oibríonn an t-iompar tagartha uathoibríoch seo
toisc go bhfuil glacadóir soiléir ag modhanna - an cineál <code>self</code>. I bhfianaise an ghlacadóra
agus ainm an mhodha, is féidir le Rust a dhéanamh amach go cinntitheach an bhfuil an modh
ag léamh (<code>&amp;self</code>), ag mutating (<code>&amp;mut self</code>), nó ag ithe (<code>self</code>). An bhfíric
go dtugann Rust iasachtaíocht intuigthe do ghlacadóirí modhanna is cuid mhór de
úinéireacht a dhéanamh eirgeanamaíochta go praiticiúil.</p>
</blockquote>
<h3 id="modhanna-le-tuilleadh-paraiméadair"><a class="header" href="#modhanna-le-tuilleadh-paraiméadair">Modhanna le Tuilleadh Paraiméadair</a></h3>
<p>Déanaimis modhanna a chleachtadh trí mhodh eile a chur i bhfeidhm ar an <code>Rectangle</code>
struchtúr. An uair seo ba mhaith linn sampla de <code>Rectangle</code> a ghlacadh mar shampla eile
de <code>Rectangle</code> agus seol ar ais <code>true</code> más féidir leis an dara <code>Rectangle</code> oiriúnach go hiomlán
laistigh de <code>self</code> (an chéad <code>Rectangle</code>); ar shlí eile, ba cheart go dtabharfadh sé <code>false</code> ar ais.
Is é sin, nuair a bheidh an modh <code>can_hold</code> sainmhínithe againn, ba mhaith linn a bheith in ann scríobh
an clár a thaispeántar i Liosta 5-14.</p>
<Listing number="5-14" file-name="src/main.rs" caption="Using the as-yet-unwritten `can_hold` method">
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
</Listing>
<p>Bheadh ​​cuma mar seo a leanas ar an aschur a bhfuiltear ag súil leis toisc go bhfuil an dá thoise de
tá <code>rect2</code> níos lú ná toisí <code>rect1</code>, ach tá <code>rect3</code> níos leithne ná
<code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>Tá a fhios againn gur mhaith linn modh a shainiú, mar sin beidh sé laistigh den <code>impl Rectangle</code>
bloc. Is é an t-ainm modha <code>can_hold</code>, agus tógfaidh sé iasacht neamh-inmhalartaithe
de <code>Rectangle</code> eile mar pharaiméadar. Is féidir linn a insint cad é an cineál an
Déanfar paraiméadar trí bhreathnú ar an gcód a ghlaonn an modh:
Gabhann <code>rect1.can_hold(&amp;rect2)</code> isteach in <code>&amp;rect2</code>, ar iasacht do-inmheasúnaithe é
<code>rect2</code>, sampla de <code>Rectangle</code>. Déanann sé seo ciall mar ní gá dúinn ach
léigh <code>rect2</code> (seachas scríobh, rud a chiallódh go mbeadh iasacht sho-shóite de dhíth orainn),
agus ba mhaith linn go gcoimeádfadh <code>main</code> úinéireacht ar <code>rect2</code> ionas gur féidir linn é a úsáid arís ina dhiaidh sin
ag glaoch ar an modh <code>can_hold</code>. Is é luach aischuir <code>can_hold</code> ná a
Beidh Boole, agus an cur i bhfeidhm a sheiceáil cibé an leithead agus airde
tá <code>self</code> níos mó ná leithead agus airde an <code>Rectangle</code> eile,
faoi ​​seach. Cuirimis an modh nua <code>can_hold</code> leis an mbloc <code>impl</code> ó
Liostú 5-13, léirithe i Liostú 5-15.</p>
<Listing number="5-15" file-name="src/main.rs" caption="Implementing the `can_hold` method on `Rectangle` that takes another `Rectangle` instance as a parameter">
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Nuair a rithimid an cód seo leis an <code>main</code> i Liostú 5-14, gheobhaidh muid ár
aschur inmhianaithe. Is féidir le modhanna a ghlacadh paraiméadair iolracha a chuirimid leis an
síniú tar éis an pharaiméadar <code>self</code>, agus oibríonn na paraiméadair sin díreach mar a chéile
paraiméadair i bhfeidhmeanna.</p>
<h3 id="feidhmeanna-gaolmhara"><a class="header" href="#feidhmeanna-gaolmhara">Feidhmeanna Gaolmhara</a></h3>
<p>Tugtar <em>feidhmeanna gaolmhara</em> ar gach feidhm a shainítear laistigh de bhloc <code>impl</code>
toisc go bhfuil baint acu leis an gcineál atá ainmnithe i ndiaidh an <code>impl</code>. Is féidir linn a shainiú
feidhmeanna gaolmhara nach bhfuil <code>self</code> mar a gcéad pharaiméadar acu (agus mar sin
nach modhanna iad) toisc nach bhfuil sampla den chineál ag teastáil uathu le bheith ag obair leo.
Tá feidhm amháin mar seo úsáidte againn cheana féin: an fheidhm <code>String::from</code> .Tá feidhm amháin
mar seo úsáidte againn cheana féin: an fheidhm <code>String::from</code> a shainmhínítear ar an gcineál <code>String</code>.</p>
<p>Is minic a úsáidtear feidhmeanna gaolmhara nach modhanna iad le haghaidh tógálaithe a
tabharfaidh sé sampla nua den struchtúr ar ais. Is minic a dtugtar <code>new</code> orthu seo, ach
Ní ainm speisialta é ‘nua’ agus níl sé fite fuaite sa teanga. Mar shampla, táimid
d'fhéadfadh sé a roghnú feidhm ghaolmhar darb ainm <code>square</code> a sholáthar a bheadh ​​aici
paraiméadar toise amháin agus é sin a úsáid mar leithead agus airde araon, rud a fhágann go bhfuil sé
níos éasca <code>Rectangle</code> cearnach a chruthú seachas a bheith ag sonrú an rud céanna
luach faoi dhó:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>Is iad na heochairfhocail <code>self</code> sa chineál tuairisceáin agus i gcorp na feidhme
ailiasanna don chineál a thagann i ndiaidh an eochairfhocail <code>impl</code>, atá sa chás seo
is <code>Rectangle</code>.</p>
<p>Chun an fheidhm ghaolmhar seo a ghlaoch, úsáidimid an chomhréir <code>::</code> leis an ainm struct;
Is sampla é <code>let sq = Rectangle::square(3);</code>. Tá an fheidhm seo spásáilte le
an struct: úsáidtear an chomhréir <code>::</code> don dá fheidhm chomhcheangailte agus
spásanna ainmneacha cruthaithe ag modúil. Déanfaimid modúil a phlé i <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">Caibidil
7</a> <!-- neamhaird a dhéanamh -->.</p>
<h3 id="bloic-impl-iolracha"><a class="header" href="#bloic-impl-iolracha">Bloic <code>impl</code> iolracha</a></h3>
<p>Ceadaítear bloic iolracha <code>impl</code> a bheith ag gach struchtúr. Mar shampla, Liostú
Tá 5-15 comhionann leis an gcód a thaispeántar i Liosta 5-16, a bhfuil gach modh ann
a bhloc <code>impl</code> féin.</p>
<Listing number="5-16" caption="Rewriting Listing 5-15 using multiple `impl` blocks">
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Níl aon chúis leis na modhanna seo a dheighilt ina mbloic <code>impl</code> iolracha anseo,
ach is comhréir bailí é seo. Feicfimid cás ina bhfuil bloic <code>impl</code> iolracha
úsáideach i gCaibidil 10, ina bpléimid cineálacha agus tréithe cineálacha.</p>
<h2 id="achoimre"><a class="header" href="#achoimre">Achoimre</a></h2>
<p>Ligeann struchtúir duit cineálacha saincheaptha a chruthú a bhfuil brí leo do d'fhearann. Le
ag baint úsáide as struchtúir, is féidir leat píosaí sonraí gaolmhara a choinneáil ceangailte lena chéile
agus ainmnigh gach píosa chun do chód a dhéanamh soiléir. I mbloic <code>impl</code>, is féidir leat a shainiú
feidhmeanna a bhaineann le do chineál, agus modhanna atá ar chineál an
fheidhm ghaolmhar a ligeann duit a shonrú ar an iompar go cásanna de do
tá struchtúir.</p>
<p>Ach ní hiad struchtúir an t-aon bhealach ar féidir leat cineálacha saincheaptha a chruthú: déanaimis iompú orthu
Gné Rust's enum chun uirlis eile a chur le do bhosca uirlisí.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-02-example-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-00-enums.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-02-example-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-00-enums.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/css/ferris.js"></script>


    </div>
    </body>
</html>
