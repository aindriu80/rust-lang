<!DOCTYPE HTML>
<html lang="ga" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Comhairgeadra Comh-Stáit - An Teanga Ríomhchláraithe Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/css/ferris.css">
        <link rel="stylesheet" href="src/css/2018-edition.css">
        <link rel="stylesheet" href="src/css/semantic-notes.css">
        <link rel="stylesheet" href="src/css/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">An Teanga Ríomhchláraithe Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/aindriu80/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="comhthráthacht-comhroinnte"><a class="header" href="#comhthráthacht-comhroinnte">Comhthráthacht Comhroinnte</a></h2>
<p>Is bealach breá é teachtaireachtaí a sheoladh chun comhthráthacht a láimhseáil, ach ní hé an t-aon cheann amháin é. Modh eile a bheadh ​​ann ná go mbeadh rochtain ag ilshnáitheanna ar na sonraí comhroinnte céanna. Smaoinigh ar an gcuid seo den mana ó dhoiciméadú teanga Go
arís: "ná déan cumarsáid trí chuimhne a roinnt."</p>
<p>Cén chuma a bheadh ​​ar chumarsáid trí chuimhne a roinnt? Ina theannta sin, cén fáth a
dtabharfadh díograiseoirí teachtaireachtaí rabhadh gan comhroinnt cuimhne a úsáid?</p>
<p>Ar bhealach, tá bealaí in aon teanga ríomhchlárúcháin cosúil le húinéireacht aonair,
mar nuair a aistríonn tú luach síos cainéal, níor cheart duit an luach sin a úsáid a thuilleadh. Tá comhthráthacht chuimhne comhroinnte cosúil le húinéireacht iolrach: is féidir le ilshnáitheanna
rochtain a fháil ar an suíomh cuimhne céanna ag an am céanna. Mar a chonaic tú i gCaibidil 15,
áit ar chuir pointeoirí cliste úinéireacht iolrach ar fáil, is féidir le húinéireacht iolrach
castacht a chur leis toisc go gcaithfear na húinéirí éagsúla seo a bhainistiú. Cuidíonn córas cineáil Rust
agus rialacha úinéireachta go mór leis an mbainistíocht seo a fháil i gceart. Mar shampla, féachaimis ar mhútéacsanna, ceann de na bunghnéithe comhthráthachta is coitianta
le haghaidh cuimhne comhroinnte.</p>
<h3 id="Úsáid-mutexanna-chun-rochtain-ar-shonraí-a-cheadú-ó-shnáithe-amháin-ag-an-am"><a class="header" href="#Úsáid-mutexanna-chun-rochtain-ar-shonraí-a-cheadú-ó-shnáithe-amháin-ag-an-am">Úsáid Mutexanna chun Rochtain ar Shonraí a Cheadú ó Shnáithe Amháin ag an Am</a></h3>
<p>Is giorrúchán é <em>Mutex</em> do <em>eisiamh frithpháirteach</em>, mar atá, ní cheadaíonn mutex ach do
shnáithe amháin rochtain a fháil ar shonraí áirithe ag aon am ar leith. Chun rochtain a fháil ar na sonraí i
mutex, ní mór do shnáithe a chur in iúl ar dtús go bhfuil rochtain uaidh trí iarraidh <em>glas</em> an
mutex a fháil. Is struchtúr sonraí é an glas atá mar chuid den mutex a
choinníonn súil ar cé a bhfuil rochtain eisiach aige ar na sonraí faoi láthair. Dá bhrí sin, déantar cur síos ar an
mutex mar <em>chosaint</em> na sonraí atá aige tríd an gcóras glasála.</p>
<p>Tá cáil ar Mutexanna as a bheith deacair a úsáid mar caithfidh tú
dhá riail a mheabhrú:</p>
<ul>
<li>Ní mór duit iarracht a dhéanamh an glas a fháil sula n-úsáideann tú na sonraí.</li>
<li>Nuair a bheidh tú críochnaithe leis na sonraí a chosnaíonn an mutex, ní mór duit na sonraí a dhíghlasáil
ionas gur féidir le snáitheanna eile an glas a fháil.</li>
</ul>
<p>Mar mheafar fíorshaoil ​​do mutex, samhlaigh plé painéil ag
comhdháil le micreafón amháin. Sula bhféadann painéalaí labhairt, caithfidh siad a iarraidh nó comhartha a thabhairt gur mian leo an micreafón a úsáid. Nuair a fhaigheann siad an micreafón, is féidir leo labhairt chomh fada agus is mian leo agus ansin an micreafón a thabhairt don chéad phainéalaí eile a iarrann labhairt. Má dhéanann painéalaí dearmad an micreafón a thabhairt dóibh nuair a bhíonn siad críochnaithe leis, ní bheidh aon duine eile in ann labhairt. Mura n-oibríonn bainistíocht an mhicreafóin chomhroinnte, ní oibreoidh an painéal mar a bhí beartaithe!</p>
<p>Is féidir go mbeadh sé thar a bheith deacair bainistíocht mutex a dhéanamh i gceart, agus sin an fáth go bhfuil an oiread sin daoine díograiseach faoi chainéil. Mar sin féin, a bhuíochas le córas cineáil agus rialacha úinéireachta Rust, ní féidir leat dul i ngleic le glasáil agus díghlasáil.</p>
<h4 id="api-mutext"><a class="header" href="#api-mutext">API <code>Mutex&lt;T&gt;</code></a></h4>
<p>Mar shampla de conas mutex a úsáid, déanaimis tosú trí mutex a úsáid i gcomhthéacs aon-snáithe, mar a thaispeántar i Liostáil 16-12:</p>
<Listing number="16-12" file-name="src/main.rs" caption="Exploring the API of `Mutex<T>` in a single-threaded context for simplicity">
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
</Listing>
<p>Mar is amhlaidh le go leor cineálacha, cruthaímid <code>Mutex&lt;T&gt;</code> ag baint úsáide as an bhfeidhm ghaolmhar <code>new</code>.
Chun rochtain a fháil ar na sonraí taobh istigh den mutex, úsáidimid an modh <code>lock</code> chun an
glas a fháil. Cuirfidh an glao seo bac ar an snáithe reatha ionas nach féidir leis aon obair a dhéanamh go dtí
go mbeidh sé inár seal an glas a bheith againn.</p>
<p>Theipfeadh ar an nglao ar <code>lock</code> dá mbeadh scaoll ar snáithe eile a bhfuil an glas aige. Sa
chás sin, ní bheadh ​​​​aon duine in ann an glas a fháil riamh, mar sin roghnaigh muid <code>unwrap</code> agus an snáithe seo a bheith i scaoll má bhímid sa chás sin.</p>
<p>Tar éis dúinn an glas a fháil, is féidir linn an luach fillte, ar a dtugtar <code>num</code> sa
chás seo, a láimhseáil mar thagairt inathraithe do na sonraí taobh istigh. Cinntíonn an córas cineáil
go bhfaighimid glas sula n-úsáidimid an luach i <code>m</code>. Is é <code>Mutex&lt;i32&gt;</code> cineál <code>m</code>, ní <code>i32</code>, mar sin <em>ní mór</em> dúinn glaoch ar <code>lock</code> chun go mbeimid in ann an luach <code>i32</code> a úsáid. Ní féidir linn dearmad a dhéanamh; ní ligfidh an córas cineáil dúinn rochtain a fháil ar an <code>i32</code> istigh
ar shlí eile.</p>
<p>Mar a d'fhéadfá a cheapadh, is pointeoir cliste é <code>Mutex&lt;T&gt;</code>. Níos cruinne, tugann an glao
chun <code>glasáil</code> <em>ar ais</em> pointeoir cliste ar a dtugtar <code>MutexGuard</code>, fillte i
<code>LockResult</code> a láimhseáil muid leis an nglao chun <code>unwrap</code>. Cuireann an pointeoir cliste <code>MutexGuard</code> <code>Deref</code> i bhfeidhm chun pointeáil ar ár sonraí istigh; tá cur i bhfeidhm <code>Drop</code> ag an bpointeoir cliste freisin
a scaoileann an glas go huathoibríoch nuair a théann
<code>MutexGuard</code> lasmuigh den raon feidhme, rud a tharlaíonn ag deireadh an raon feidhme istigh. Mar thoradh air sin, níl an baol ann go ndéanaimid dearmad an glas a scaoileadh agus bac a chur ar an mutex
ó bheith á úsáid ag snáitheanna eile, toisc go dtarlaíonn an scaoileadh glas
go huathoibríoch.</p>
<p>Tar éis an glas a scaoileadh, is féidir linn an luach mutex a phriontáil agus a fheiceáil gur éirigh linn an <code>i32</code> istigh a athrú go 6.</p>
<h4 id="mutext-a-roinnt-idir-snáitheanna-iolracha"><a class="header" href="#mutext-a-roinnt-idir-snáitheanna-iolracha"><code>Mutex&lt;T&gt;</code> a roinnt idir snáitheanna iolracha</a></h4>
<p>Anois, déanaimis iarracht luach a roinnt idir snáitheanna iolracha ag baint úsáide as <code>Mutex&lt;T&gt;</code>.
Déanfaimid 10 snáithe a chasadh suas agus méadóimid luach cuntair faoi 1, ionas
go dtéann an cuntar ó 0 go 10. Beidh earráid tiomsaitheora sa chéad sampla eile i Liosta 16-13, agus úsáidfimid an earráid sin chun níos mó a fhoghlaim faoi úsáid <code>Mutex&lt;T&gt;</code> agus conas a chabhraíonn Rust linn é a úsáid i gceart.</p>
<Listing number="16-13" file-name="src/main.rs" caption="Ten threads each increment a counter guarded by a `Mutex<T>`">
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
</Listing>
<p>Cruthaímid athróg <code>counter</code> chun <code>i32</code> a choinneáil taobh istigh de <code>Mutex&lt;T&gt;</code>, mar a rinneamar i Liostáil 16-12. Ansin, cruthaímid 10 snáithe trí athrá a dhéanamh thar raon uimhreacha. Úsáidimid <code>thread::spawn</code> agus tugann muid an dúnadh céanna do na snáitheanna go léir: ceann a bhogann an t-counter isteach sa snáithe, a fhaigheann glas ar an <code>Mutex&lt;T&gt;</code> trí ghlaoch ar an modh <code>lock</code>, agus ansin cuireann sé 1 leis an luach sa mutex. Nuair a chríochnaíonn snáithe a dhúnadh, rachaidh <code>num</code> as raon feidhme agus scaoilfidh sé an
glas ionas gur féidir le snáithe eile é a fháil.</p>
<p>Sa phríomhshnáithe, bailímid na láimhseálacha join go léir. Ansin, mar a rinneamar i Liostáil 16-2, glaoimid <code>join</code> ar gach láimhseáil chun a chinntiú go gcríochnaíonn na snáitheanna go léir. Ag an bpointe sin, gheobhaidh an príomhshnáithe an glas agus priontálfaidh sé toradh an chláir seo.</p>
<p>Thugamar le fios nach ndéanfadh an sampla seo a thiomsú. Anois, déanaimis a fháil amach cén fáth!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Deir an teachtaireacht earráide gur aistríodh luach an <code>counter</code> san athrá roimhe seo den lúb. Tá Rust ag insint dúinn nach féidir linn úinéireacht <code>counter</code> a bhogadh isteach i snáitheanna iolracha. Déanaimis an earráid tiomsaitheora a shocrú le modh ilúinéireachta a phléamar i gCaibidil 15.</p>
<h4 id="ilúinéireacht-le-snáitheanna-iolracha"><a class="header" href="#ilúinéireacht-le-snáitheanna-iolracha">Ilúinéireacht le Snáitheanna Iolracha</a></h4>
<p>I gCaibidil 15, thugamar luach ilúinéirí trí úsáid a bhaint as an pointeoir cliste <code>Rc&lt;T&gt;</code> chun luach comhaireamh tagartha a chruthú. Déanaimis an rud céanna anseo agus feicfimid cad a tharlaíonn. Fillfimid an <code>Mutex&lt;T&gt;</code> i <code>Rc&lt;T&gt;</code> i Liostáil 16-14 agus clónálfaimid an <code>Rc&lt;T&gt;</code> sula mbogfaimid úinéireacht chuig an snáithe.</p>
<Listing number="16-14" file-name="src/main.rs" caption="Attempting to use `Rc<T>` to allow multiple threads to own the `Mutex<T>`">
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
</Listing>
<p>Arís eile, déanaimid tiomsú agus faighimid... earráidí difriúla! Tá an tiomsaitheoir ag múineadh go leor dúinn.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:36
    |
11  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
    | |                      |
    | |                      required by a bound introduced by this call
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
    |
    = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`, which is required by `{closure@src/main.rs:11:36: 11:43}: Send`
note: required because it's used within this closure
   --&gt; src/main.rs:11:36
    |
11  |         let handle = thread::spawn(move || {
    |                                    ^^^^^^^
note: required by a bound in `spawn`
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/src/thread/mod.rs:675:8
    |
672 | pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    |        ----- required by a bound in this function
...
675 |     F: Send + 'static,
    |        ^^^^ required by this bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Ó, tá an teachtaireacht earráide sin an-fhoclach! Seo an chuid thábhachtach le díriú air:
<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely </code>. Tá an tiomsaitheoir ag
insint dúinn an chúis freisin: <code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>. Labhróimid faoi <code>Send</code> sa chéad chuid eile: is ceann de
na tréithe é a chinntíonn go bhfuil na cineálacha a úsáidimid le snáitheanna ceaptha lena n-úsáid i
gcásanna comhthráthacha.</p>
<p>Ar an drochuair, níl <code>Rc&lt;T&gt;</code> sábháilte a roinnt trasna snáitheanna. Nuair a bhainistíonn <code>Rc&lt;T&gt;</code>
an comhaireamh tagartha, cuireann sé leis an gcomhaireamh do gach glao chuig <code>clone</code> agus
baineann sé ón gcomhaireamh nuair a scaoiltear gach clón. Ach ní úsáideann sé aon
bhunphrionsabail chomhthráthacha chun a chinntiú nach féidir le snáithe eile
cur isteach ar athruithe ar an gcomhaireamh. D’fhéadfadh sé seo a bheith ina chúis le comhaireamh mícheart—fabhtanna caolchúiseacha a
d’fhéadfadh sceitheanna cuimhne nó luach a chailleadh sula mbeidh muid críochnaithe
leis. Is cineál atá díreach cosúil le <code>Rc&lt;T&gt;</code> atá de dhíth orainn ach ceann a dhéanann athruithe
ar an gcomhaireamh tagartha ar bhealach atá sábháilte ó thaobh snáithe de.</p>
<h4 id="comhaireamh-tagartha-adamhach-le-arct"><a class="header" href="#comhaireamh-tagartha-adamhach-le-arct">Comhaireamh Tagartha Adamhach le <code>Arc&lt;T&gt;</code></a></h4>
<p>Ar ámharaí an tsaoil, is cineál cosúil le <code>Rc&lt;T&gt;</code> é <code>Arc&lt;T&gt;</code> atá sábháilte le húsáid i
gcásanna comhthráthacha. Seasann an <em>a</em> do <em>atomic</em>, rud a chiallaíonn gur cineál <em>adamhach
comhairimh</em> tagartha é. Is cineál breise comhthráthachta
bunaidh iad adamhach nach gclúdóimid go mion anseo: féach ar an doiciméadú
leabharlainne caighdeánach le haghaidh <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- neamhaird --> le haghaidh tuilleadh
sonraí. Ag an bpointe seo, níl le déanamh agat ach a fhios a bheith agat go n-oibríonn adamhach cosúil le cineálacha
bunaidh ach go bhfuil siad sábháilte a roinnt trasna snáitheanna.</p>
<p>B’fhéidir go mbeadh iontas ort ansin cén fáth nach bhfuil gach cineál primitive adamhach agus cén fáth nach gcuirtear cineálacha caighdeánacha leabharlainne i bhfeidhm chun <code>Arc&lt;T&gt;</code> a úsáid de réir réamhshocraithe. Is é an chúis atá leis sin ná go dtagann pionós feidhmíochta le sábháilteacht snáithe nach mian leat a íoc ach nuair a
bhíonn gá agat leis i ndáiríre. Má tá tú ag déanamh oibríochtaí ar luachanna laistigh de
shnáithe amháin, is féidir le do chód rith níos tapúla mura gá dó na
ráthaíochtaí a sholáthraíonn adamhach a fhorfheidhmiú.</p>
<p>Fillfimid ar ár sampla: Tá an API céanna ag <code>Arc&lt;T&gt;</code> agus <code>Rc&lt;T&gt;</code>, mar sin socraímid
ár gclár tríd an líne <code>use</code>, an glao go <code>new</code>, agus an glao go
<code>clone</code> a athrú. Tiomsóidh agus rithfidh an cód i Liosta 16-15 sa deireadh:</p>
<Listing number="16-15" file-name="src/main.rs" caption="Using an `Arc<T>` to wrap the `Mutex<T>` to be able to share ownership across multiple threads">
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre></pre>
</Listing>
<p>Priontálfaidh an cód seo an méid seo a leanas:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>Rinneamar é! Chomhaireamhamar ó 0 go 10, rud nach mbeadh an-suntasach b'fhéidir, ach mhúin sé go leor dúinn faoi <code>Mutex&lt;T&gt;</code> agus sábháilteacht snáitheanna. D'fhéadfá struchtúr an chláir seo a úsáid freisin chun oibríochtaí níos casta a dhéanamh ná díreach cuntar a mhéadú. Ag baint úsáide as an straitéis seo, is féidir leat ríomh a roinnt ina chodanna neamhspleácha, na codanna sin a roinnt thar shnáitheanna, agus ansin <code>Mutex&lt;T&gt;</code> a úsáid chun go ndéanfaidh gach
snáithe an toradh deiridh a nuashonrú lena chuid.</p>
<p>Tabhair faoi deara, má tá tú ag déanamh oibríochtaí uimhriúla simplí, go bhfuil cineálacha níos simplí ann
ná cineálacha <code>Mutex&lt;T&gt;</code> arna soláthar ag an modúl <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code> den
leabharlann chaighdeánach</a><!-- ignore -->. Soláthraíonn na cineálacha seo rochtain shábháilte, chomhuaineach,
adamhach ar chineálacha primitive. Roghnaíomar <code>Mutex&lt;T&gt;</code> a úsáid le cineál primitive
don sampla seo ionas go bhféadfaimis díriú ar an gcaoi a n-oibríonn <code>Mutex&lt;T&gt;</code>.</p>
<h3 id="cosúlachtaí-idir-refcelltrct-agus-mutextarct"><a class="header" href="#cosúlachtaí-idir-refcelltrct-agus-mutextarct">Cosúlachtaí idir <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> agus <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>B’fhéidir gur thug tú faoi deara nach féidir an <code>counter</code> a athrú ach go bhféadfaimis tagairt inathraithe a fháil don luach atá istigh ann; ciallaíonn sé seo go soláthraíonn <code>Mutex&lt;T&gt;</code> inathraitheacht inmheánach, mar a dhéanann an teaghlach <code>Cell</code>. Ar an gcaoi chéanna a d’úsáideamar <code>RefCell&lt;T&gt;</code> i
gCaibidil 15 chun ligean dúinn ábhar a athrú laistigh de <code>Rc&lt;T&gt;</code>, úsáidimid <code>Mutex&lt;T&gt;</code> chun ábhar a athrú laistigh de <code>Arc&lt;T&gt;</code>.</p>
<p>Sonra eile le tabhairt faoi deara ná nach féidir le Rust tú a chosaint ó gach cineál earráide loighce
nuair a úsáideann tú <code>Mutex&lt;T&gt;</code>. Cuimhnigh i gCaibidil 15 gur tháinig an baol timthriallta tagartha a chruthú le húsáid <code>Rc&lt;T&gt;</code>, áit a dtagraíonn dhá luach <code>Rc&lt;T&gt;</code> dá chéile, rud a fhágann sceitheanna cuimhne. Ar an gcaoi chéanna, tá an baol ann go gcruthófar <em>deadlocks</em> le <code>Mutex&lt;T&gt;</code>. Tarlaíonn siad seo nuair a bhíonn ar oibríocht dhá acmhainn a ghlasáil
agus nuair a bhíonn ceann de na glais faighte ag dhá shnáithe, rud a fhágann go bhfanann siad
le chéile go deo. Más spéis leat deadlocks, déan iarracht clár Rust a chruthú
a bhfuil deadlock ann; ansin déan taighde ar straitéisí maolaithe deadlock do
mutexes in aon teanga agus déan iarracht iad a chur i bhfeidhm i Rust. Cuireann
an doiciméadú caighdeánach leabharlainne API do <code>Mutex&lt;T&gt;</code> agus <code>MutexGuard</code>
eolas úsáideach ar fáil.</p>
<p>Cuirfimid clabhsúr ar an gcaibidil seo trí labhairt faoi na tréithe <code>Send</code> agus <code>Sync</code> agus
conas is féidir linn iad a úsáid le cineálacha saincheaptha.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-02-message-passing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-04-extensible-concurrency-sync-and-send.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-02-message-passing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-04-extensible-concurrency-sync-and-send.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/css/ferris.js"></script>


    </div>
    </body>
</html>
