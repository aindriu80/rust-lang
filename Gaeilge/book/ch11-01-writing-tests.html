<!DOCTYPE HTML>
<html lang="ga" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Conas a Scríobh Tástálacha - An Teanga Ríomhchláraithe Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/css/ferris.css">
        <link rel="stylesheet" href="src/css/2018-edition.css">
        <link rel="stylesheet" href="src/css/semantic-notes.css">
        <link rel="stylesheet" href="src/css/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">An Teanga Ríomhchláraithe Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/aindriu80/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="conas-trialacha-a-scríobh"><a class="header" href="#conas-trialacha-a-scríobh">Conas Trialacha a Scríobh</a></h2>
<p>Is feidhmeanna Rust iad tástálacha a fhíoraíonn go bhfuil an cód neamhthástála ag feidhmiú i
an modh ionchais. Is gnách go ndéanann coirp na bhfeidhmeanna tástála na trí cinn seo
gníomhartha:</p>
<ul>
<li>Socraigh aon sonraí nó stáit atá ag teastáil.</li>
<li>Rith an cód is mian leat a thástáil.</li>
<li>Dearbhaigh gurb iad na torthaí a bhfuil tú ag súil leo.</li>
</ul>
<p>Breathnaímid ar na gnéithe a sholáthraíonn Rust go sonrach chun tástálacha a scríobh
déan na gníomhartha seo, lena n-áirítear an tréith <code>test</code>, cúpla macra, agus an
tréith <code>should_panic</code>.</p>
<h3 id="anatamaíocht-na-feidhme-tástála"><a class="header" href="#anatamaíocht-na-feidhme-tástála">Anatamaíocht na Feidhme Tástála</a></h3>
<p>Ar a simplí, is feidhm í tástáil in Rust atá anótáilte leis an <code>test</code>
tréith. Is meiteashonraí iad tréithe faoi phíosaí de chód Meirge; sampla amháin is ea
an tréith <code>derive</code> a d'úsáideamar le structs i gCaibidil 5. Feidhm a athrú
isteach i bhfeidhm tástála, cuir <code>#[test]</code> ar an líne roimh <code>fn</code>. Nuair a ritheann tú do
tástálacha leis an ordú <code>cargo test</code>, tógann Rust dénártha rádala tástála a ritheann
na feidhmeanna agus na tuarascálacha anótáilte ar cibé acu an n-éiríonn le gach feidhm tástála nó
theipeann.</p>
<p>Aon uair a dhéanaimid tionscadal leabharlainne nua le Cargo, modúl tástála le tástáil
gintear feidhm ann go huathoibríoch dúinn. Tugann an modúl seo duit a
teimpléad chun do thástálacha a scríobh ionas nach mbeidh ort féachaint suas go cruinn
struchtúr agus comhréir gach uair a chuireann tú tús le tionscadal nua. Is féidir leat an oiread
feidhmeanna tástála breise agus an oiread modúil tástála agus is mian leat!</p>
<p>Fiosróimid roinnt gnéithe den chaoi a n-oibríonn tástálacha trí thástáil a dhéanamh leis an teimpléad
tástáil sula ndéanaimid tástáil iarbhír ar aon chód. Ansin scríobhfaimid roinnt tástálacha sa saol fíor
a thugann roinnt cód scríofa againn agus a dhearbhaíonn go bhfuil a iompar ceart.</p>
<p>Cruthaímid tionscadal leabharlainne nua darb ainm <code>adder</code> a chuirfidh dhá uimhir leis:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>Ba cheart go mbeadh cuma ar a bhfuil sa chomhad <em>src/lib.rs</em> i do leabharlann <code>adder</code>
Liostáil 11-1.</p>
<Listing number="11-1" file-name="src/lib.rs" caption="The code generated automatically by `cargo new`">
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>Tosaíonn an comhad le sampla <code>add</code> feidhm, ionas go mbeidh rud éigin againn
a thástáil.</p>
<p>Faoi láthair, dírímid ar an bhfeidhm <code>it_works</code> amháin. Tabhair faoi deara an <code>#[test]</code>
nóta: léiríonn an tréith seo feidhm tástála, mar sin an tástáil
tá a fhios ag rádala an fheidhm seo a chóireáil mar thástáil. Seans go mbeidh neamhthástáil againn freisin
feidhmeanna sa mhodúl <code>tests</code> chun cuidiú le cásanna comónta a shocrú nó le cur i gcrích
oibríochtaí coitianta, mar sin ní mór dúinn a chur in iúl i gcónaí cé na feidhmeanna atá ina dtrialacha.</p>
<p>Úsáideann an comhlacht feidhme samplach an macra <code>assert_eq!</code> chun a dhearbhú go bhfuil <code>result</code>,
ina bhfuil an toradh ar ghlaoch <code>add</code> le 2 agus 2, cothrom le 4. Seo
feidhmíonn dearbhú mar shampla den fhormáid do ghnáththástáil. Rithfimid é
féachaint go n-éiríonn leis an tástáil seo.</p>
<p>Ritheann an t-ordú <code>cargo test</code> na tástálacha go léir inár dtionscadal, mar a thaispeántar i Liostú
11-2.</p>
<Listing number="11-2" caption="The output from running the automatically generated test">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (file:///projects/adder/target/debug/deps/adder-7acb243c25ffd9dc)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
</Listing>
<p>Chuir lasta le chéile agus rith an tástáil. Feicimid an líne <code>running 1 test</code>. An chéad cheann eile
léiríonn an líne ainm na feidhme tástála ginte, ar a dtugtar <code>tests::it_works</code>,
agus go bhfuil toradh na trialach sin <code>ok</code>. An achoimre iomlán <code>test result: ok.</code> ciallaíonn sé gur ritheadh ​​na tástálacha go léir, agus an chuid a léann <code>1 passed; 0 failed</code> líon na dtrialacha a d'éirigh leo nó ar theip orthu.</p>
<p>Is féidir triail a mharcáil mar thástáil nach dtugtar aird uirthi agus mar sin ní ritheann sé go háirithe
shampla ; clúdóimid é sin sa <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">“Neamhaird a thabhairt ar Roinnt Trialacha Mura Go Sonrach
Iarrtha”</a><!-- neamhaird --> alt níos déanaí sa chaibidil seo
nach bhfuil déanta agat anseo, léiríonn an achoimre <code>0 ignored</code>.</p>
<p>Baineann an staitistic <code>0 measured</code> le tástálacha tagarmhairc a thomhaiseann feidhmíocht.
Níl tástálacha tagarmharcála ar fáil, ón scríbhinn seo, ach amháin i Rust gach oíche. Féach
<a href="../unstable-book/library-features/test.html">na doiciméid faoi thástálacha tagarmharcála</a> chun tuilleadh a fhoghlaim.</p>
<p>Is féidir linn argóint a chur ar aghaidh chuig an ordú <code>cargo test</code> gan ach tástálacha a bhfuil a
oireann an t-ainm le teaghrán; tugtar <em>filtering</em> air seo agus clúdóimid é sin sa
<a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">“Fothacar Trialacha á Rith de réir Ainm”</a><!-- neamhaird a dhéanamh ar --> alt. Seo muid
nár scagadh na tástálacha atá á rith, mar sin taispeánann deireadh na hachoimre <code>0 filtered out</code>.</p>
<p>Tá an chéad chuid eile den aschur tástála ag tosú ag <code>Doc-tests adder</code> le haghaidh an
torthaí aon tástálacha doiciméadachta. Níl aon tástálacha doiciméadaithe againn go fóill,
ach is féidir le Rust aon samplaí cód atá le feiceáil inár ndoiciméadú API a thiomsú.
Cuidíonn an ghné seo le do dhoiciméid agus do chód a choinneáil ar comhchiall! Déanfaimid plé ar conas
scríobh trialacha doiciméadúcháin sa <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“Tuairimí Cáipéisíochta mar
Tástálacha”</a><!-- neamhaird --> alt de Chaibidil 14. Go dtí seo, beidh muid
neamhaird a dhéanamh den aschur <code>Doc-tests</code>.</p>
<p>Tosaímid ar an tástáil a shaincheapadh dár riachtanais féin. Ar dtús, athraigh ainm
an fheidhm <code>it_works</code> chuig ainm eile, mar <code>exploration</code>, mar sin:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Then run <code>cargo test</code> again. The output now shows <code>exploration</code> instead of
<code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Anois cuirfimid triail eile leis, ach an uair seo déanfaimid tástáil a mhainneoidh! Tástálacha
theipeann nuair a scaoll rud éigin sa fheidhm tástála. Reáchtáiltear gach tástáil i gceann nua
snáithe, agus nuair a fheiceann an príomh-snáithe go bhfuil snáithe tástála bás, is é an tástáil
marcáilte mar theip. I gCaibidil 9, labhair muid faoi conas an bealach is simplí chun scaoll
Is é an macra <code>panic!</code> a ghlaoch. Cuir isteach an tástáil nua mar fheidhm ainmnithe
<code>another</code>, mar sin tá cuma ar do chomhad <em>src/lib.rs</em> Liostú 11-3.</p>
<Listing number="11-3" file-name="src/lib.rs" caption="Adding a second test that will fail because we call the `panic!` macro">
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}</code></pre>
</Listing>
<p>Rith na tástálacha arís ag úsáid <code>cargo test</code>. Ba cheart go mbeadh cuma Liostú ar an aschur
11-4, a thaispeánann gur theip ar ár dtástáil <code>exploration</code> agus ar <code>another</code>.</p>
<Listing number="11-4" caption="Test results when one test passes and one test fails">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
</Listing>
<!-- manual-regeneration
rg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt
check the line number of the panic matches the line number in the following paragraph
 -->
<p>In ionad <code>ok</code>, taispeánann an líne <code>test tests::another</code> <code>FAILED</code>. Beirt nua
ailt le feiceáil idir na torthaí aonair agus an achoimre: an chéad
léiríonn sé an chúis mhionsonraithe le gach teip tástála. Sa chás seo, faigheann muid an
sonraí ar theip ar <code>another</code> toisc go raibh scaoll air ag 'Make this test fail'` ar
líne 17 sa chomhad <em>src/lib.rs</em>. Níl sa chéad chuid eile ach ainmneacha gach duine
na tástálacha a dteipeann orthu, rud atá úsáideach nuair a bhíonn go leor tástálacha agus go leor
aschur tástála teip mhionsonraithe. Is féidir linn an t-ainm tástála teip a úsáid chun rith díreach
an tástáil sin chun é a dhífhabhtú ar bhealach níos éasca; Labhróimid níos mó faoi bhealaí le tástálacha a reáchtáil
an [“Conas a Reáchtáiltear Tástálacha a Rialú”][rialú-conas-a-rithtear na tástálacha]<!-- neamhaird a dhéanamh
--> alt.</p>
<p>Taispeánann an líne achoimre ag an deireadh: tríd is tríd, is é toradh ár dtástála <code>FAILED</code>. muid
bhí pas tástála amháin agus teip tástála amháin.</p>
<p>Anois go bhfuil cuma thorthaí na dtástálacha i gcásanna éagsúla feicthe agat,
Breathnaímid ar roinnt macraí seachas <code>panic!</code> atá úsáideach i dtrialacha.</p>
<h3 id="torthaí-á-seiceáil-leis-an-macra-asert"><a class="header" href="#torthaí-á-seiceáil-leis-an-macra-asert">Torthaí á Seiceáil leis an Macra <code>Asert!</code></a></h3>
<p>Tá an macra <code>assert!</code>, a sholáthraíonn an leabharlann chaighdeánach, úsáideach nuair is mian leat
chun a chinntiú go meastar riocht éigin i dtástáil go <code>true</code>. Tugann muid an
macra <code>assert!</code> argóint a dhéanann meastóireacht ar Boole. Má tá an luach
<code>true</code>, ní tharlaíonn aon rud agus éiríonn leis an tástáil. Más <code>false</code> an luach, beidh an
Glaonn an macra ar <code>panic!</code> chun teip a chur ar an tástáil. Ag baint úsáide as an <code>assert!</code>
Cuidíonn macra linn seiceáil go bhfuil ár gcód ag feidhmiú ar an mbealach atá beartaithe againn.</p>
<p>I gCaibidil 5, Liosta 5-15, d'úsáideamar struchtúr <code>Rectangle</code> agus <code>can_hold</code>
modh, a dhéantar arís anseo i Liosta 11-5. Cuirimis an cód seo sa
<em>src/lib.rs</em>, ansin scríobh roinnt tástálacha dó ag baint úsáide as an macra <code>assert!</code>.</p>
<Listing number="11-5" file-name="src/lib.rs" caption="The `Rectangle` struct and its `can_hold` method from Chapter 5">
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
</Listing>
<p>Tugann an modh <code>can_hold</code> Boole ar ais, rud a chiallaíonn gur cás úsáide foirfe é
don mhacra <code>asert!</code>. I Liostáil 11-6, scríobhaimid triail a chleachtann an
modh <code>can_hold</code> trí shampla <code>Rectangle</code> a chruthú a bhfuil leithead 8 agus
airde 7 agus ag maíomh gur féidir leis sampla eile <code>Rectangle</code> a choinneáil
tá leithead 5 agus airde 1 aige.</p>
<Listing number="11-6" file-name="src/lib.rs" caption="A test for `can_hold` that checks whether a larger rectangle can indeed hold a smaller rectangle">
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
</Listing>
<p>Tabhair faoi deara an líne <code>use super::*;</code> taobh istigh den mhodúl <code>tests</code>. Is é an modúl <code>tests</code>
modúl rialta a leanann na gnáthrialacha infheictheachta a chlúdaíomar i gCaibidil
7 sa [“Cosáin chun Tagairt a Dhéanamh do Mhír sa Mhodúl
Crann”][cosáin-le-tagairt-go-mír-sa-crann-mhodúil]<!-- neamhaird -->
alt. Toisc gur modúl istigh é an modúl <code>tests</code>, caithfimid an
cód faoi thástáil sa mhodúl seachtrach isteach i raon feidhme an mhodúil istigh. úsáidimid
glob anseo, mar sin tá aon rud a shainímid sa mhodúl seachtrach ar fáil dó seo
modúl <code>tests</code>.</p>
<p>D’ainmnigh muid ár dtástáil ‘larger_can_hold_smaller’, agus chruthaíomar an dá cheann
Cásanna <code>Rectangle</code> a theastaíonn uainn. Ansin thugamar an macra <code>assert!</code> agus
rith sé mar thoradh ar ghlaoch ar <code>more.can_hold(&amp;smaller)</code>. Tá an abairt seo
ceaptha a thabhairt ar ais `` fíor, mar sin ba chóir ár tástáil pas a fháil. Faighimis amach!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Ritheann sé! Cuirimis tástáil eile leis, an uair seo á dhearbhú go bhfuil níos lú
ní féidir le dronuilleog dronuilleog níos mó a choinneáil:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>Toisc go bhfuil toradh ceart na feidhme <code>can_hold</code> sa chás seo <code>false</code>,
caithfimid an toradh sin a dhiúltú sula gcuirfimid ar aghaidh chuig an macra <code>assert!</code> é. Mar a
Mar thoradh air sin, rithfidh ár dtástáil má fhilleann <code>can_hold</code> <code>false</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Dhá thástáil a éiríonn! Anois féachaimis cad a tharlóidh dár dtorthaí tástála nuair a dhéanaimid
bug a thabhairt isteach inár gcód. Athróimid cur i bhfeidhm an <code>can_hold</code>
trí chomhartha níos lú ná an comhartha a chur in ionad an chomhartha is mó ná é
i gcomparáid leis na leithead:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Táirgeann rith na dtrialacha na nithe seo a leanas anois:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Fuair ​​​​ár tástálacha an fabht! Toisc go bhfuil <code>larger.width</code> <code>8</code> agus <code>smaller.width</code> is
<code>5</code>, filleann an chomparáid idir na leithead in <code>can_hold</code> anois <code>false</code>: níl 8
níos lú ná 5.</p>
<h3 id="comhionannas-á-thástáil-leis-na-macraí-assert_eq-agus-assert_ne"><a class="header" href="#comhionannas-á-thástáil-leis-na-macraí-assert_eq-agus-assert_ne">Comhionannas á Thástáil leis na Macraí <code>assert_eq!</code> agus <code>assert_ne!</code></a></h3>
<p>Bealach coiteann chun feidhmiúlacht a fhíorú is ea tástáil le haghaidh comhionannais idir an toradh
den chód atá faoi thástáil agus an luach a bhfuil súil agat go dtabharfaidh an cód ar ais. D'fhéadfá
Déan é seo tríd an macra <code>assert!</code> a úsáid agus slonn a chur air ag baint úsáide as an
<code>==</code> oibreoir. Mar sin féin, tá sé seo chomh coitianta go bhfuil an leabharlann caighdeánach
soláthraíonn sé péire macraí —<code>assert_eq!</code> agus <code>assert_ne!</code>—chun an triail seo a dhéanamh
níos áisiúla. Déanann na macraí seo comparáid idir dhá argóint ar son comhionannais nó
éagothroime, faoi seach. Déanfaidh siad an dá luach a phriontáil freisin más é an dearbhú
theipeann, rud a fhágann gur fusa <em>why</em> theip ar an tástáil a fheiceáil; a mhalairt, an
Ní thugann macra <code>assert!</code> le fios ach go bhfuair sé luach <code>false</code> don <code>==</code>
léiriú, gan na luachanna ba chúis leis an luach <code>false</code> a phriontáil.</p>
<p>I Liostú 11-7, scríobhaimid feidhm darb ainm <code>add_two</code> a chuireann <code>2</code> lena
paraiméadar, ansin déanaimid tástáil ar an bhfeidhm seo ag baint úsáide as an macra <code>assert_eq!</code>.</p>
<Listing number="11-7" file-name="src/lib.rs" caption="Testing the function `add_two` using the `assert_eq!` macro">
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>Déanaimis seiceáil go n-éiríonn leis!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Cruthaímid athróg darb ainm <code>result</code> a choinníonn toradh an ghlao
<code>add_two(2)</code>. Ansin cuirimid <code>result</code> agus <code>4</code> ar aghaidh mar na hargóintí go <code>assert_eq!</code>.
Is é an líne aschuir don triail seo ná <code>test tests::it_adds_two ... ok</code>, agus an <code>ok</code>
téacs le fios go bhfuil ár tástáil a rith!</p>
<p>Cuirimis fabht isteach inár gcód féachaint cén chuma atá ar <code>assert_eq!</code> nuair atá sé
theipeann. Athraigh cur i bhfeidhm na feidhme <code>add_two</code> chun <code>3</code> a chur leis ina ionad sin:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Rith na tástálacha arís:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Fuair ​​​​ár dtástáil an fabht! Theip ar an tástáil <code>it_adds_two</code>, agus insíonn an teachtaireacht
dúinn <code>assertion `left == right` failed</code> agus cad iad na luachanna <code>left</code> agus <code>right</code>
bhfuil. Cuidíonn an teachtaireacht seo linn tús a chur le dífhabhtaithe: an argóint <code>left</code>, áit a raibh againn
ba é an toradh ar ghlaoch <code>add_two(2)</code>, ná <code>5</code> ach ba é <code>4</code> an argóint <code>right</code>.
Is féidir leat a shamhlú go mbeadh sé seo cabhrach go háirithe nuair a bhíonn go leor againn
tástálacha ar siúl.</p>
<p>Tabhair faoi deara, i roinnt teangacha agus creataí tástála, na paraiméadair don chomhionannas
Tugtar <code>expected</code> agus <code>actual</code> ar fheidhmeanna dearbhaithe, agus an t-ord ina bhfuil
sonraímid cúrsaí na n-argóintí. Mar sin féin, i Rust, tugtar <code>left</code> agus
<code>right</code>, agus an t-ord ina sonraímid an luach a mbeimid ag súil leis agus an luach
is cuma leis an gcód a tháirgtear. D’fhéadfaimis an dearbhú a scríobh sa triail seo mar
<code>assert_eq!(4, result)</code>, rud a thabharfadh an teachtaireacht teipe céanna
a thaispeánann <code>assertion failed: `(left == right)`</code>.</p>
<p>Rachaidh an macra <code>assert_ne!</code> mura bhfuil an dá luach a thugaimid dó cothrom agus
teip má tá siad comhionann. Tá an macra seo an-úsáideach i gcásanna nuair nach bhfuilimid cinnte
cén luach <em>will</em>, ach tá a fhios againn cad é an luach nár cheart a bheith.
Mar shampla, má táimid ag tástáil feidhm atá ráthaithe a hionchur a athrú
ar bhealach éigin, ach braitheann an bealach a athraítear an t-ionchur ar an lá de
an tseachtain a bhfuil ár dtrialacha á reáchtáil againn, b'fhéidir gurb é an rud is fearr le dearbhú go bhfuil an
nach bhfuil aschur na feidhme comhionann leis an ionchur.</p>
<p>Faoin dromchla, úsáideann na macraí <code>assert_eq!</code> agus <code>assert_ne!</code> na hoibreoirí
<code>==</code> agus <code>!=</code>, faoi seach. Nuair a theipeann ar na dearbhuithe, déanann na macraí seo a gcuid
argóintí a úsáideann formáidiú dífhabhtaithe, rud a chiallaíonn go gcaithfidh na luachanna atá á gcur i gcomparáid
na tréithe <code>PartialEq</code> agus <code>Debug</code> a chur i bhfeidhm. Gach cineál primitive agus an chuid is mó de
cuireann na gnáthchineálacha leabharlainne na tréithe seo i bhfeidhm. Le haghaidh struchtúir agus enums go
a shainíonn tú féin, beidh ort <code>PartialEq</code> a chur i bhfeidhm chun comhionannas a dhearbhú
na cineálacha sin. Beidh ort <code>Debug</code> a chur i bhfeidhm freisin chun na luachanna a phriontáil nuair a bheidh an
theipeann ar dhearbhú. Toisc gur tréithe díorthaithe iad an dá thréith, mar a luadh i
Ag liostú 5-12 i gCaibidil 5, bíonn sé seo chomh simplí de ghnáth le cur leis an
<code>#[derive(PartialEq, Debug)]</code> anótáil le do shainmhíniú struchtúr nó enum. Féach
Aguisín C, [“Tréithe In-Díorthaithe,”][tréithe derivable]<!-- neamhaird a dhéanamh ar --> le haghaidh tuilleadh
sonraí faoi na tréithe seo agus tréithe díorthacha eile.</p>
<h3 id="teachtaireachtaí-teip-saincheaptha-á-gcur-leis"><a class="header" href="#teachtaireachtaí-teip-saincheaptha-á-gcur-leis">Teachtaireachtaí Teip Saincheaptha á gcur leis</a></h3>
<p>Is féidir leat freisin teachtaireacht saincheaptha a phriontáil leis an teachtaireacht teip mar
argóintí roghnacha leis na macraí <code>assert!</code>, <code>assert_eq!</code>, agus <code>asert_ne!</code>. ar bith
argóintí a shonraítear tar éis na hargóintí riachtanacha a chur ar aghaidh chuig an
macra <code>format!</code> (a pléadh i gCaibidil 8 sa [“Concatenation with the <code>+</code>
Oibreoir nó an <code>format!</code>
Macra”][concatenation-with-the--operator-nó-an-format-macra]<!-- neamhaird -->
alt), ionas gur féidir leat teaghrán formáide a chur ar aghaidh ina bhfuil sealbhóirí áitribh <code>{}</code> agus
luachanna le dul sna háitsealbhóirí sin. Tá teachtaireachtaí saincheaptha úsáideach le doiciméadú
cad is brí le dearbhú; nuair a theipeann ar thástáil, beidh tuiscint níos fearr agat ar cad é
Is í an fhadhb leis an gcód.</p>
<p>Mar shampla, déarfaimis go bhfuil feidhm againn a thugann beannú do dhaoine de réir ainm agus muid
ag iarraidh a thástáil go bhfuil an t-ainm a chuirimid isteach san fheidhm le feiceáil san aschur:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>Níl na riachtanais don chlár seo aontaithe go fóill, agus táimid
cinnte go n-athrófar an téacs <code>Hello</code> ag tús na Beannachta. muid
chinn nach dteastaíonn uainn go mbeadh orainn an tástáil a nuashonrú nuair a athraíonn na riachtanais,
mar sin in ionad a sheiceáil le haghaidh comhionannais beacht leis an luach ar ais ó na
feidhm <code>greeting</code>, ní dhéanfaidh muid ach dearbhú go bhfuil téacs an
paraiméadar ionchuir.</p>
<p>Anois cuirimis fabht isteach sa chód seo trí <code>greeting</code> a athrú chun eisiamh
<code>name</code> chun a fheiceáil cén chuma atá ar an teip tástála réamhshocraithe:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Táirgeann an tástáil seo a leanas:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Tugann an toradh seo le fios gur theip ar an dearbhú agus cén líne an
tá dearbhú ar siúl. Dhéanfadh teachtaireacht teip níos úsáidí an luach a phriontáil ón
feidhm <code>greeting</code>. Cuirimis teachtaireacht teipe saincheaptha leis comhdhéanta d’fhormáid
teaghrán le áitshealbhóir líonta isteach leis an luach iarbhír a fuaireamar ón
feidhm <code>greeting</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>Anois agus an tástáil á rith againn, gheobhaidh muid teachtaireacht earráide níos faisnéiseach:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Is féidir linn an luach a fuaireamar i ndáiríre san aschur tástála a fheiceáil, rud a chabhródh linn
debug cad a tharla in ionad an méid a bhí muid ag súil a tharlóidh.</p>
<h3 id="ag-seiceáil-le-haghaidh-panics-le-should_panic"><a class="header" href="#ag-seiceáil-le-haghaidh-panics-le-should_panic">Ag seiceáil le haghaidh Panics le <code>should_panic</code></a></h3>
<p>Chomh maith le luachanna fillte a sheiceáil, tá sé tábhachtach a sheiceáil go bhfuil ár gcód
láimhseálann sé coinníollacha earráide agus muid ag súil leis. Mar shampla, smaoinigh ar an gcineál <code>Guess</code>
a chruthaíomar i gCaibidil 9, Liosta 9-13. Cód eile a úsáideann <code>Guess</code>
ag brath ar an ráthaíocht nach mbeidh ach luachanna sna cásanna <code>Guess</code>
idir 1 agus 100. Is féidir linn triail a scríobh a chinntíonn go ndéanfar iarracht a dhéanamh a
<code>Guess</code> shampla le luach lasmuigh den raon scaoll.</p>
<p>Déanaimid é seo tríd an tréith <code>should_panic</code> a chur lenár bhfeidhm tástála. Tá an
Gabhann tástáil má tá an cód laistigh den fheidhm scaoll; theipeann ar an tástáil má tá an cód
taobh istigh den fheidhm ní scaoll.</p>
<p>Léiríonn liostú 11-8 tástáil a sheiceálann go dtarlaíonn coinníollacha earráide <code>Guess::new</code>
nuair a mbeimid ag súil leo.</p>
<Listing number="11-8" file-name="src/lib.rs" caption="Testing that a condition will cause a `panic!`">
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p>Cuirimid an aitreabúid <code>#[should_panic]</code> tar éis an aitreabúid <code>#[test]</code> agus
roimh an fheidhm tástála a mbaineann sé léi. Breathnaímid ar an toradh nuair a bheidh an tástáil seo
Gabhann:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Breathnaíonn go maith! Anois tugaimid fabht isteach inár gcód tríd an riocht a bhaint
go rachaidh an fheidhm <code>new</code> i scaoll má tá an luach níos mó ná 100:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Nuair a rithfimid an tástáil i Liostú 11-8, teipfidh uirthi:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Ní fhaighimid teachtaireacht an-chabhrach sa chás seo, ach nuair a fhéachaimid ar an triail
fheidhm, feicimid go bhfuil sé anótáilte le <code>#[should_panic]</code>. An teip a fuair muid
Ciallaíonn sé sin nach raibh an cód san fheidhm tástála ina chúis le scaoll.</p>
<p>Is féidir le tástálacha a úsáideann <code>should_panic</code> a bheith neamhchruinn. Dhéanfadh tástáil <code>should_panic</code>
pas a fháil fiú má tá an scaoll tástála ar chúis eile ón gceann a bhí muid
ag súil. Chun tástálacha <code>should_panic</code> a dhéanamh níos cruinne, is féidir linn rogha roghnach a chur leis
paraiméadar <code>expected</code> don aitreabúid <code>should_panic</code>. Déanfaidh an úim tástála
déan cinnte go bhfuil an téacs curtha ar fáil sa teachtaireacht teip. Mar shampla,
smaoinigh ar an gcód modhnaithe do <code>Guess</code> i Liostú 11-9 mar a bhfuil an fheidhm <code>new</code>
panics le teachtaireachtaí éagsúla ag brath ar cibé an bhfuil an luach ró-bheag nó
ró-mhór.</p>
<Listing number="11-9" file-name="src/lib.rs" caption="Testing for a `panic!` with a panic message containing a specified substring">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p>Rachaidh an tástáil seo thar mar gheall ar an luach a chuireamar san aitreabúid <code>should_panic</code>''s
Fotheaghrán is ea an paraiméadar <code>expected</code> den teachtaireacht a thugann an <code>Guess::new</code>
scaoll feidhm le . D'fhéadfaimis an teachtaireacht scaoll iomlán a shonraigh muid
ag súil leis, a bheadh ​​sa chás seo a bheith <code>Guess value must be less than or equal to 100, got 200</code>. Braitheann an méid a roghnaíonn tú a shonrú ar cé mhéad den scaoll
tá an teachtaireacht uathúil nó dinimiciúil agus cé chomh beacht is mian leat do thástáil a bheith. I seo
cás, tá fotheideal den teachtaireacht scaoll go leor chun a chinntiú go bhfuil an cód sa
feidhmíonn an fheidhm tástála an cás <code>else if value &gt; 100</code>.</p>
<p>Féach cad a tharlaíonn nuair a thástáil <code>should_panic</code> le teachtaireacht <code>expected</code>
theipeann, cuirimis fabht isteach inár gcód arís trí chorpáin an
<code>if value &lt; 1</code> agus na bloic <code>else if value &gt; 100</code>:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>An uair seo nuair a ritheann muid an tástáil <code>should_panic</code>, teipfidh sé:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Tugann an teachtaireacht teip le fios go ndearna an tástáil seo scaoll go deimhin agus muid ag súil leis,
ach níor chuimsigh an teachtaireacht scaoill an teaghrán ionchais <code>níos lú ná nó cothrom go dtí 100</code>. Ba é an teachtaireacht scaoll a fuair muid sa chás seo ná <code>Guess value must a bheith níos mó ná nó cothrom le 1, fuair 200.</code> Anois is féidir linn tosú figuring amach cén áit
Is é ár fabht!</p>
<h3 id="ag-baint-úsáide-as-resultt-e-i-dtrialacha"><a class="header" href="#ag-baint-úsáide-as-resultt-e-i-dtrialacha">Ag baint úsáide as <code>Result&lt;T, E&gt;</code> i dTrialacha</a></h3>
<p>Ár tástálacha go dtí seo go léir scaoll nuair a theipeann orthu. Is féidir linn tástálacha a scríobh freisin a úsáideann
<code>Result&lt;T, E&gt;</code>! Seo an tástáil ó Liostú 11-1, athscríofa chun <code>Result&lt;T, E&gt;</code> agus seol ar ais <code>Err</code> in ionad scaoll a dhéanamh:</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
<span class="boring">}</span></code></pre>
<p>Tá an cineál tuairisceáin <code>Result&lt;(), String&gt;</code> anois ag an bhfeidhm <code>it_works</code>. Sna
comhlacht na feidhme, seachas glaoch ar an <code>assert_eq!</code> macra, táimid ar ais
<code>Ok(())</code> nuair a éiríonn leis an triail agus <code>Err</code> le <code>String</code> istigh nuair a bheidh an tástáil
theipeann.</p>
<p>Trialacha a scríobh ionas go dtabharfaidh siad <code>Result&lt;T, E&gt;</code> ar do chumas an cheist a úsáid
oibreoir marc i gcorp na tástálacha, is féidir a bheith ina bhealach áisiúil a scríobh
tástálacha ba cheart a theipeann orthu má thugann oibríocht ar bith laistigh díobh leagan <code>Err</code> ar ais.</p>
<p>Ní féidir leat an nóta <code>#[should_panic]</code> a úsáid ar thástálacha a úsáideann <code>Result&lt;T, E&gt;</code>. Chun a dhearbhú go dtugann oibríocht athróg <code>Err</code> ar ais, <em>ná</em> húsáid an
oibreoir comhartha ceiste ar an luach <code>Result&lt;T, E&gt;</code>. Ina áit sin, bain úsáid as
<code>assert!(value.is_err())</code>.</p>
<p>Anois go bhfuil roinnt bealaí ar eolas agat chun trialacha a scríobh, féachaimis ar a bhfuil ag tarlú
nuair a rithimid ár dtrialacha agus nuair a dhéanaimid iniúchadh ar na roghanna éagsúla is féidir linn a úsáid le <code>cargo test</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-00-testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-02-running-tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-00-testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-02-running-tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/css/ferris.js"></script>


    </div>
    </body>
</html>
